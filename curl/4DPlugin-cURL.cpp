/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-cURL.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : cURL
 #	author : miyako
 #	2021/03/30
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-cURL.h"

std::mutex mutexPf;
std::mutex mutexMcurl;

pxProxyFactory *pf = NULL;
CURLM *gmcurl = NULL;

static void OnStartup() {
    
    curl_global_init(CURL_GLOBAL_DEFAULT);
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        gmcurl = curl_multi_init();
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexPf);
        
        pf = px_proxy_factory_new();
    }
    
}

static void OnExit() {
    
    if(gmcurl)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        curl_multi_cleanup(gmcurl);
        gmcurl = NULL;
    }
    
    curl_global_cleanup();
    
    if(pf)
    {
        std::lock_guard<std::mutex> lock(mutexPf);
        
        px_proxy_factory_free(pf);
        pf = NULL;
    }
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
             
            case kDeinitPlugin :
            case kServerDeinitPlugin :
                OnExit();
                break;
                
			// --- cURL
            
			case 1 :
				cURL_VersionInfo(params);
				break;
			case 2 :
				cURL_Escape(params);
				break;
			case 3 :
				cURL_Unescape(params);
				break;
			case 4 :
				cURL_GetDate(params);
				break;
			case 5 :
				_cURL(params);
				break;
                
            case 6 :
                cURL_FTP(params, curl_ftp_command_Delete);
                break;
            case 7 :
                cURL_FTP(params, curl_ftp_command_GetDirList);
                break;
            case 8 :
                cURL_FTP(params, curl_ftp_command_GetFileInfo);
                break;
            case 9 :
                cURL_FTP(params, curl_ftp_command_MakeDir);
                break;
            case 10 :
                cURL_FTP(params, curl_ftp_command_PrintDir);
                break;
            case 11 :
                cURL_FTP(params, curl_ftp_command_Receive);
                break;
            case 12 :
                cURL_FTP(params, curl_ftp_command_RemoveDir);
                break;
            case 13 :
                cURL_FTP(params, curl_ftp_command_Rename);
                break;
            case 14 :
                cURL_FTP(params, curl_ftp_command_Send);
                break;
            case 15 :
                cURL_FTP(params, curl_ftp_command_System);
                break;
        }

	}
	catch(...)
	{

	}
}

static size_t curl_read_function(void *buffer,
                          size_t size,
                          size_t nmemb,
                          http_ctx *ctx) {
    
    size_t len = size * nmemb;
    
    if(ctx->size)
    {
        FILE *f;
        
        f = CPathOpen (ctx->path, CPathRead);
        
        if(f)
        {
            fseek(f, ctx->pos, SEEK_SET);
            len = fread(buffer, size, nmemb, f);
            ctx->pos += len;
            fclose(f);
        }else
        {
            len = 0;
        }
    }else
    {
        const uint8_t *ptr = ctx->data->getBytesPtrForSize((uint32_t *)&len);
        if(ptr) memcpy(buffer, ptr, len);
    }
    
    return len;
}

static size_t curl_header_function(char *buffer,
                            size_t size,
                            size_t nmemb,
                            http_ctx *ctx) {
    
    size_t len = size * nmemb;
    ctx->data->addBytes((const uint8_t *)buffer, (unsigned int)len);
    
    return len;
}

static bool create_folder(path_t *absolute_path) {
    
    bool success = false;
    
#if VERSIONMAC
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
    NSFileManager *fm = [[NSFileManager alloc]init];
    success = [fm createDirectoryAtPath:path
            withIntermediateDirectories:YES
                             attributes:nil
                                  error:NULL];
    [path release];
    [fm release];
#else
    success = SHCreateDirectory(NULL, (PCWSTR)absolute_path);
#endif
    
    return success;
}

static void create_parent_folder(path_t *absolute_path) {
    
#if VERSIONMAC
    NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
    absolute_path_t folderPath = absolute_path_t([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
    create_folder((path_t *)folderPath.c_str());
    [filePath release];
#else
    wchar_t    fDrive[_MAX_DRIVE],
    fDir[_MAX_DIR],
    fName[_MAX_FNAME],
    fExt[_MAX_EXT];
    _wsplitpath_s(absolute_path, fDrive, fDir, fName, fExt);
    absolute_path_t folderPath = fDrive;
    folderPath += fDir;
    create_folder((path_t *)folderPath.c_str());
#endif
}

static size_t curl_debug_function(CURL *curl,
                                  curl_infotype type,
                                  char *data,
                                  size_t size,
                                  http_debug_ctx *ctx) {

       #if VERSIONMAC
           std::string path;
           path = (const char *)ctx->path;
       #else
           std::wstring path;
           path = (const wchar_t *)ctx->path;
       #endif
           
           curl_off_t  *f_size = NULL;
           
           switch (type)
           {
               case CURLINFO_TEXT:
                   path += LOG_CURLINFO_TEXT;
                   f_size = &ctx->size_CURLINFO_TEXT;
                   break;
               case CURLINFO_HEADER_IN:
                   path += LOG_CURLINFO_HEADER_IN;
                   f_size = &ctx->size_CURLINFO_HEADER_IN;
                   break;
               case CURLINFO_HEADER_OUT:
                   path += LOG_CURLINFO_HEADER_OUT;
                   f_size = &ctx->size_CURLINFO_HEADER_OUT;
                   break;
               case CURLINFO_DATA_IN:
                   path += LOG_CURLINFO_DATA_IN;
                   f_size = &ctx->size_CURLINFO_DATA_IN;
                   break;
               case CURLINFO_DATA_OUT:
                   path += LOG_CURLINFO_DATA_OUT;
                   f_size = &ctx->size_CURLINFO_DATA_OUT;
                   break;
               case CURLINFO_SSL_DATA_OUT:
                   path += LOG_CURLINFO_SSL_DATA_IN;
                   f_size = &ctx->size_CURLINFO_SSL_DATA_IN;
                   break;
               case CURLINFO_SSL_DATA_IN:
                   path += LOG_CURLINFO_SSL_DATA_OUT;
                   f_size = &ctx->size_CURLINFO_SSL_DATA_OUT;
                   break;
               case CURLINFO_END:
                   break;
           }

           create_parent_folder((path_t *)path.c_str());
           FILE *f = CPathOpen ((path_t *)path.c_str(), *f_size ? CPathAppend : CPathCreate);
           
           if(f)
           {
               *f_size += size;
               fwrite(data, size, sizeof(char), f);
               fclose(f);
           }

           return 0;
       }

static size_t curl_write_function(void *buffer,
                           size_t size,
                           size_t nmemb,
                           http_ctx *ctx) {
    
    size_t len = size * nmemb;
    
    if(ctx->use_path)
    {
        create_parent_folder((path_t *)ctx->path);
        FILE *f = CPathOpen (ctx->path, ctx->size ? CPathAppend : CPathCreate);
        
        if(f)
        {
            ctx->size += len;
            fwrite(buffer, size, nmemb, f);
            fclose(f);
        }else
        {
            len = 0;
        }
        
    }else
    {
        ctx->data->addBytes((const uint8_t *)buffer, (unsigned int)len);
    }
    
    return len;
}

static void curl_get_info(CURL *curl, PA_ObjectRef transferInfo) {
    
    if(transferInfo) {
     
        long responseCode, connectCode, fileTime,
        redirectCount, headerSize, requestSize, lastSocket,
        sslVerifyResult, localPort, primaryPort, numConnects,
        osErrNo, httpAuthAvail, proxyAuthAvail,
        rtspClientCseq, rtspServerCseq, rtspCseqRecv, conditionUnmet;
        double totalTime, nameLookupTime, connectTime,
        appConnectTime, preTransferTime, startTransferTime, redirectTime;
        
        /*
        long sizeUpload, speedUpload, sizeDownload, speedDownload,
        contentLengthDownload, contentLengthUpload;
         */
        
        char *effectiveUrl = NULL;
        char *redirectUrl = NULL;
        char *contentType = NULL;
        char *ftpEntryPath = NULL;
        char *localIp = NULL;
        char *primaryIp = NULL;
        char *rtspSessionId = NULL;
        
        curl_off_t speedUploadT, speedDownloadT, sizeUploadT,
        sizeDownloadT, contentLengthDownloadT, contentLengthUploadT;
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &conditionUnmet)) {
            ob_set_n(transferInfo, "conditionUnmet", conditionUnmet);
        }
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_UPLOAD_T, &contentLengthUploadT)) {
            ob_set_n(transferInfo, "contentLengthUpload", contentLengthUploadT);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD_T, &contentLengthDownloadT)) {
            ob_set_n(transferInfo, "contentLengthDownload", contentLengthDownloadT);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD_T, &speedUploadT)) {
            ob_set_n(transferInfo, "speedUpload", speedUploadT);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD_T, &speedDownloadT)) {
            ob_set_n(transferInfo, "speedDownload", speedDownloadT);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD_T, &sizeDownloadT)) {
            ob_set_n(transferInfo, "sizeDownload", sizeDownloadT);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD_T, &sizeUploadT)) {
            ob_set_n(transferInfo, "sizeUpload", sizeUploadT);
        }

        curl_off_t totalTimeT, nameLookupTimeT, connectTimeT,
        preTransferTimeT, startTransferTimeT, redirectTimeT,
        appConnectTimeT;
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME_T, &totalTimeT)) {
            ob_set_n(transferInfo, "totalTime", totalTimeT);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME_T, &nameLookupTimeT)) {
            ob_set_n(transferInfo, "nameLookupTime", nameLookupTimeT);
        }
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME_T, &connectTimeT)) {
            ob_set_n(transferInfo, "connectTime", connectTimeT);
        }
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME_T, &preTransferTimeT)) {
            ob_set_n(transferInfo, "preTransferTime", preTransferTimeT);
        }
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME_T, &startTransferTimeT)) {
            ob_set_n(transferInfo, "startTransferTime", startTransferTimeT);
        }
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME_T, &redirectTimeT)) {
            ob_set_n(transferInfo, "redirectTime", redirectTimeT);
        }
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME_T, &appConnectTimeT)) {
            ob_set_n(transferInfo, "appConnectTime", appConnectTimeT);
        }
        
        curl_off_t retryAfterT;
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RETRY_AFTER, &retryAfterT)) {
            ob_set_n(transferInfo, "retryAfter", retryAfterT);
        }
        
        long proxyError;
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PROXY_ERROR, &proxyError)) {
            ob_set_n(transferInfo, "proxyError", proxyError);
        }
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CLIENT_CSEQ, &rtspClientCseq)) {
            ob_set_n(transferInfo, "rtspClientCseq", rtspClientCseq);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SERVER_CSEQ, &rtspServerCseq)) {
            ob_set_n(transferInfo, "rtspServerCseq", rtspServerCseq);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CSEQ_RECV, &rtspCseqRecv)) {
            ob_set_n(transferInfo, "rtspCseqRecv", rtspCseqRecv);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LASTSOCKET, &lastSocket)) {
            ob_set_n(transferInfo, "lastSocket", lastSocket);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT, &primaryPort)) {
            ob_set_n(transferInfo, "primaryPort", primaryPort);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT, &localPort)) {
            ob_set_n(transferInfo, "localPort", localPort);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE, &connectCode)) {
            ob_set_n(transferInfo, "connectCode", connectCode);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FILETIME, &fileTime)) {
            ob_set_n(transferInfo, "fileTime", fileTime);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &totalTime)) {
            ob_set_n(transferInfo, "totalTime", totalTime);
        }
         
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE , &requestSize)) {
            ob_set_n(transferInfo, "requestSize", requestSize);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &headerSize)) {
            ob_set_n(transferInfo, "headerSize", headerSize);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTPAUTH_AVAIL, &httpAuthAvail)) {
            ob_set_n(transferInfo, "httpAuthAvail", httpAuthAvail);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PROXYAUTH_AVAIL, &proxyAuthAvail)) {
            ob_set_n(transferInfo, "proxyAuthAvail", proxyAuthAvail);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_OS_ERRNO, &osErrNo)) {
            ob_set_n(transferInfo, "osErrNo", osErrNo);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &numConnects)) {
            ob_set_n(transferInfo, "numConnects", numConnects);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &responseCode)) {
            ob_set_n(transferInfo, "responseCode", responseCode);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME, &nameLookupTime)) {
            ob_set_n(transferInfo, "nameLookupTime", nameLookupTime);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &connectTime)) {
            ob_set_n(transferInfo, "connectTime", connectTime);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME, &appConnectTime)) {
            ob_set_n(transferInfo, "appConnectTime", appConnectTime);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME, &preTransferTime)) {
            ob_set_n(transferInfo, "preTransferTime", preTransferTime);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME, &startTransferTime)) {
            ob_set_n(transferInfo, "startTransferTime", startTransferTime);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME, &redirectTime)) {
            ob_set_n(transferInfo, "redirectTime", redirectTime);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT , &sslVerifyResult)) {
            ob_set_n(transferInfo, "sslVerifyResult", sslVerifyResult);
        }

        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &redirectCount)) {
            ob_set_n(transferInfo, "redirectCount", redirectCount);
        }
        
        long protocol, proxySslVerifyResult, httpVersion;
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTP_VERSION, &httpVersion)) {
            ob_set_n(transferInfo, "httpVersion", httpVersion);
        }
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PROXY_SSL_VERIFYRESULT, &proxySslVerifyResult)) {
            ob_set_n(transferInfo, "proxySslVerifyResult", proxySslVerifyResult);
        }
        
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PROTOCOL, &protocol)) {
            ob_set_n(transferInfo, "protocol", protocol);
        }

        if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &effectiveUrl))) {
            ob_set_s(transferInfo, "effectiveUrl", effectiveUrl ? effectiveUrl : "");
        }
        
        char *effectiveMethod = NULL;
        
        if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_METHOD, &effectiveMethod))) {
            ob_set_s(transferInfo, "effectiveMethod", effectiveMethod ? effectiveMethod : "");
        }

        if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_IP, &localIp))) {
            ob_set_s(transferInfo, "localIp", localIp ? localIp : "");
        }

        if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &contentType))) {
            ob_set_s(transferInfo, "contentType", contentType ? contentType : "");
        }

        if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP, &primaryIp))) {
            ob_set_s(transferInfo, "primaryIp", primaryIp ? primaryIp : "");
        }

        if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &redirectUrl))) {
            ob_set_s(transferInfo, "redirectUrl", redirectUrl ? redirectUrl : "");
        }

        if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &ftpEntryPath))) {
            ob_set_s(transferInfo, "ftpEntryPath", ftpEntryPath ? ftpEntryPath : "");
        }

        if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SESSION_ID, &rtspSessionId))) {
            ob_set_s(transferInfo, "rtspSessionId", rtspSessionId ? rtspSessionId : "");
        }
        
        char *scheme = NULL;
        
        if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SCHEME, &scheme))) {
            ob_set_s(transferInfo, "scheme", scheme ? scheme : "");
        }
    }
}

static CURLcode curl_perform_atomic(CURL *curl, PA_ObjectRef returnValue) {
    
    CURLcode result = CURLE_OK;
    
    std::lock_guard<std::mutex> lock(mutexMcurl);
    
    result = curl_easy_perform(curl);
        
    PA_ObjectRef transferInfo = PA_CreateObject();
    curl_get_info(curl, transferInfo);
    ob_set_o(returnValue, "transferInfo", transferInfo);
    
    return result;
}

static CURLcode curl_perform_non_atomic(CURLM *mcurl, CURL *curl, CUTF16String& methodName, C_TEXT& userInfo, PA_ObjectRef returnValue) {
        
	PA_long32 method_id = 0;
	
	bool execute_callback_method = false;

	if (methodName.length()) {
		method_id = PA_GetMethodID((PA_Unichar *)methodName.c_str());
		if (method_id == 0) {
			execute_callback_method = true;
		}
	}
	
	PA_Unistring method = PA_CreateUnistring((PA_Unichar *)methodName.c_str());

    CUTF16String info;
    CURLMcode mc = CURLM_OK; /* not used to abort */
    CURLcode result = CURLE_OK;
    
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
        
    auto startTime = std::chrono::high_resolution_clock::now();//time(0);
        
    PA_Variable    cbparams[4];
  
  	if (method_id)
	{
		cbparams[0] = PA_CreateVariable(eVK_Object);
		cbparams[1] = PA_CreateVariable(eVK_Unistring);
		PA_SetUnistring((&(cbparams[1].uValue.fString)),
			(PA_Unichar *)userInfo.getUTF16StringPtr());
	}
	if (execute_callback_method)
	{
		cbparams[0] = PA_CreateVariable(eVK_Unistring);
		cbparams[1] = PA_CreateVariable(eVK_Boolean);
		cbparams[2] = PA_CreateVariable(eVK_Object);
		cbparams[3] = PA_CreateVariable(eVK_Unistring);
		PA_SetStringVariable(&cbparams[0], &method);
		PA_SetUnistring((&(cbparams[3].uValue.fString)),
			(PA_Unichar *)userInfo.getUTF16StringPtr());
	}
    
    int running_handles = 0;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        curl_multi_add_handle(mcurl, curl);
        curl_multi_perform(mcurl, &running_handles);
    }
    
    do
    {
        PA_YieldAbsolute();
        
        struct timeval tv;
        int rc = 0;
        
        fd_set fdread;
        fd_set fdwrite;
        fd_set fdexcep;
        
        int maxfd = -1;
        long curl_timeout = -1;
        
        FD_ZERO(&fdread);
        FD_ZERO(&fdwrite);
        FD_ZERO(&fdexcep);
        
        tv.tv_sec = 1;
        tv.tv_usec = 0;
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(mutexMcurl);
            
            curl_multi_timeout(mcurl, &curl_timeout);
            
            if(curl_timeout >= 0)
            {
                tv.tv_sec = curl_timeout / 1000;
                if(tv.tv_sec > 1)
                    tv.tv_sec = 1;
                else
                    tv.tv_usec = (curl_timeout % 1000) * 1000;
            }
            
            mc = curl_multi_fdset(mcurl, &fdread, &fdwrite, &fdexcep, &maxfd);
        }
        
        if(mc != CURLM_OK)
        {
            break;
        }
        
        if(maxfd == -1)
        {
            /* https://curl.haxx.se/libcurl/c/multi-post.html */
            
            PA_Variable params[2];
            params[0] = PA_CreateVariable(eVK_Longint);
            PA_SetLongintVariable(&params[0], currentProcessNumber);
            
            params[1] = PA_CreateVariable(eVK_Real);
            PA_SetRealVariable(&params[1], 6);//100ms
            
            PA_ExecuteCommandByID(323 /*DELAY_PROCESS*/ , params, 2);
            
            PA_ClearVariable(&params[0]);
            PA_ClearVariable(&params[1]);
            
            rc = 0;
        }
        else
        {
            rc = select(maxfd+1, &fdread, &fdwrite, &fdexcep, &tv);
        }
        switch(rc) {
            case -1:
                /* select error */
                break;
            case 0:
            default:
                if(1)
                {
                    std::lock_guard<std::mutex> lock(mutexMcurl);
                    
                    /* timeout or readable/writable sockets */
                    mc = curl_multi_perform(mcurl, &running_handles);
                    /* callback method */
                }
            {

                if((method_id)||(execute_callback_method))
                {
                    auto now = std::chrono::high_resolution_clock::now();//time(0);
                    auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime).count();
                    
                    if(elapsedTime > 100)
                    {
                        startTime = now;
                        
                        std::lock_guard<std::mutex> lock(mutexMcurl);
                        
                        PA_ObjectRef transferInfo = PA_CreateObject();
                        curl_get_info(curl, transferInfo);
                        
                        PA_SetObjectVariable(&cbparams[2], transferInfo);
                        
						if (execute_callback_method) {
							PA_ExecuteCommandByID(1007 /*EXECUTE METHOD*/, cbparams, 4);
							PA_Variable statusCode = cbparams[1];
							if (PA_GetVariableKind(statusCode) == eVK_Boolean)
							{
								if (PA_GetBooleanVariable(statusCode))
								{
									/* abort */
									result = CURLE_ABORTED_BY_CALLBACK;
									goto curl_abort_transfer;
								}
							}
						}
						else {
							PA_Variable statusCode = PA_ExecuteMethodByID(method_id, cbparams, 2);
							if (PA_GetVariableKind(statusCode) == eVK_Boolean)
							{
								if (PA_GetBooleanVariable(statusCode))
								{
									/* abort */
									result = CURLE_ABORTED_BY_CALLBACK;
									goto curl_abort_transfer;
								}
							}
						}
                    }
                }else
                {
                    PA_YieldAbsolute();
                }

                PA_Variable params;
                bool isProcessDying = PA_GetBooleanVariable(PA_ExecuteCommandByID(672/* Process aborted */, &params, 0));
                /* PA_IsProcessDying is not threadSafe */
                
                if(isProcessDying)
                {
                    /* abort (runtime explorer, not debugger) */
                    result = CURLE_ABORTED_BY_CALLBACK;
                    goto curl_abort_transfer;
                }
                
            }
                break;
        }
        
    }while((running_handles));
    
curl_abort_transfer:
        
    struct CURLMsg *m;
    int msgq = 0;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        m = curl_multi_info_read(mcurl, &msgq);
        if(m && (m->msg == CURLMSG_DONE))
        {
            result = m->data.result;
            
            if(method_id)
            {
                //callback one last time
                PA_ObjectRef transferInfo = PA_CreateObject();
                curl_get_info(curl, transferInfo);
                
                PA_SetObjectVariable(&cbparams[0], transferInfo);
                
                PA_ExecuteMethodByID(method_id, cbparams, 2);
            }

        }
        
        PA_ObjectRef transferInfo = PA_CreateObject();
        curl_get_info(curl, transferInfo);
        ob_set_o(returnValue, "transferInfo", transferInfo);
        
        curl_multi_remove_handle(mcurl, curl);
    }
    
    PA_ClearVariable(&cbparams[0]);
    PA_ClearVariable(&cbparams[1]);
	PA_ClearVariable(&cbparams[2]);
    
    return result;
}

#pragma mark -

static void convert_unistring_to_string(CUTF16String& utf16value, std::string& stringValue) {
    
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)utf16value.c_str(), utf16value.length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)utf16value.c_str(), utf16value.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            stringValue = std::string((const char *)&buf[0]);
        }
    }else{
        stringValue = std::string((const char *)"");
    }
    
#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)utf16value.c_str(), utf16value.length());
    if(str){
        
        size_t size = CFStringGetMaximumSizeForEncoding(
                                                        CFStringGetLength(str),
                                                        kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str,
                         CFRangeMake(
                                     0,
                                     CFStringGetLength(str)),
                         kCFStringEncodingUTF8,
                         0, true, (UInt8 *)&buf[0], size, &len);
        
        stringValue = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}
    
static void convert_string_to_unistring(std::string& stringValue, CUTF16String& utf16value) {
    
#ifdef _WIN32
        int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)stringValue.c_str(), stringValue.length(), NULL, 0);
        if(len){
            std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
            if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)stringValue.c_str(), stringValue.length(), (LPWSTR)&buf[0], len)){
                utf16value = CUTF16String((const PA_Unichar *)&buf[0]);
            }
        }
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)stringValue.c_str(), stringValue.length(), kCFStringEncodingUTF8, true);
    if(str){
        CFIndex len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        utf16value = CUTF16String((const PA_Unichar *)&buf[0]);
        CFRelease(str);
    }
#endif
}

void cURL_VersionInfo(PA_PluginParameters params) {
    
    curl_version_info_data *d = curl_version_info(CURLVERSION_NOW);
    
    PA_ObjectRef info = PA_CreateObject();
    
    if(d->age >= 0) {
        
        ob_set_s(info, "version", d->version);
        ob_set_n(info, "version_num", d->version_num);
        ob_set_s(info, "host", d->host);
        ob_set_n(info, "features", d->features);
        ob_set_s(info, "ssl_version", d->ssl_version);
        ob_set_s(info, "libz_version", d->libz_version);

        PA_CollectionRef protocols = PA_CreateCollection();
        
        if(d->protocols)
        {
            size_t n = 0;
            size_t nproto = 0;

            while(d->protocols[nproto])
            {
                const char *protocol = d->protocols[nproto];
                size_t len = strlen(protocol);
                if(len)
                {
                    std::string stringValue = protocol;
                    CUTF16String utf16value;
                    convert_string_to_unistring(stringValue, utf16value);
                    PA_Variable v = PA_CreateVariable(eVK_Unistring);
                    PA_Unistring value = PA_CreateUnistring((PA_Unichar *)utf16value.c_str());
                    PA_SetStringVariable(&v, &value);
                    PA_SetCollectionElement(protocols, PA_GetCollectionLength(protocols), v);
                    //value belongs to v, do not call PA_DisposeUnistring
                    PA_ClearVariable(&v);
                    n += len;
                    n += ++nproto;
                }
            }
        }
        
        ob_set_c(info, "protocols", protocols);
        
        if(d->age >= 1)
        {

        }
        
        if(d->age >= 2)
        {
            if(d->libidn)
            {
                ob_set_s(info, "libidn", d->libidn);
            }
        }
        
        if(d->age >= 3)
        {
            if(d->libssh_version)
            {
                ob_set_s(info, "libssh_version", d->libssh_version);
            }
        }
        
        if(d->age >= 4)
        {
            if(d->brotli_version)
            {
                ob_set_s(info, "brotli_version", d->brotli_version);
            }
        }
        
        if(d->age >= 5)
        {

			if (d->nghttp2_version)
			{
				ob_set_s(info, "nghttp2_version", d->nghttp2_version);
			}

        }
        
        if(d->age >= 6)
        {

        }
        
        if(d->age >= 7)
        {

			if (d->zstd_version)
			{
				ob_set_s(info, "zstd_version", d->zstd_version);
			}

        }
    }
    
    PA_ReturnObject(params, info);
}

void cURL_Escape(PA_PluginParameters params) {

    C_TEXT Param1;
    C_TEXT returnValue;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    Param1.fromParamAtIndex(pParams, 1);
    
    CURL *curl = curl_easy_init();
    
    if(curl)
    {
        CUTF8String srcUrl;
        Param1.copyUTF8String(&srcUrl);
        
        char *escapedUrl = curl_easy_escape(curl, (char *)srcUrl.c_str(), (int)srcUrl.size());
        
        if(escapedUrl)
        {
            CUTF8String dstUrl;
            dstUrl = CUTF8String((const uint8_t *)escapedUrl);
            returnValue.setUTF8String(&dstUrl);
            curl_free(escapedUrl);
        }

        curl_easy_cleanup(curl);
    }

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    returnValue.setReturn(pResult);
}

void cURL_Unescape(PA_PluginParameters params) {

    C_TEXT Param1;
    C_TEXT returnValue;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    Param1.fromParamAtIndex(pParams, 1);
    
    CURL *curl = curl_easy_init();
    
    if(curl)
    {
        CUTF8String srcUrl;
        Param1.copyUTF8String(&srcUrl);
        
        int outLength;
        char *escapedUrl = curl_easy_unescape(curl, (char *)srcUrl.c_str(), (int)srcUrl.size(), &outLength);
        
        if(escapedUrl)
        {
            CUTF8String dstUrl;
            dstUrl = CUTF8String((const uint8_t *)escapedUrl, outLength);
            returnValue.setUTF8String(&dstUrl);
            curl_free(escapedUrl);
        }

        curl_easy_cleanup(curl);
    }

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    returnValue.setReturn(pResult);
}

void cURL_GetDate(PA_PluginParameters params) {
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT returnValue;

    PackagePtr pParams = (PackagePtr)params->fParameters;
    Param1.fromParamAtIndex(pParams, 1);
    
    CUTF8String datestring;
    Param1.copyUTF8String(&datestring);
    
    time_t date = curl_getdate((char *)datestring.c_str(), NULL);
    returnValue.setIntValue((int)(date < 0 || date < 0  ? -1 : date));
    
    if(date != -1)
    {
        std::vector<uint8_t> buf(20);
        memset((char *)&buf[0], 0, buf.size());
#if VERSIONMAC
        sprintf((char *)&buf[0], "%ld", date);
#else
        sprintf_s((char *)&buf[0], 20, "%ld", date);
#endif
        Param2.setUTF8String((const uint8_t *)&buf[0], (uint32_t)strlen((const char *)&buf[0]));
    }

    Param2.toParamAtIndex(pParams, 2);
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    returnValue.setReturn(pResult);

}

static void curl_easy_setopt_enum(CURL *curl, CURLoption option, CUTF8String& s) {
    
    long v = 0;
    
#define CHECK_CURLOPT_VALUE(__a,__b) if(s==(const uint8_t*)__a){v=(CURLoption)__b;goto json_get_curl_option_value_exit;}

    /* USE_SSL */
    CHECK_CURLOPT_VALUE("USESSL_NONE",CURLUSESSL_NONE)
    CHECK_CURLOPT_VALUE("USESSL_TRY",CURLUSESSL_TRY)
    CHECK_CURLOPT_VALUE("USESSL_CONTROL",CURLUSESSL_CONTROL)
    CHECK_CURLOPT_VALUE("USESSL_ALL",CURLUSESSL_ALL)

    /* SSLVERSION, PROXY_SSLVERSION */
    CHECK_CURLOPT_VALUE("SSLVERSION_DEFAULT",CURL_SSLVERSION_DEFAULT)
    CHECK_CURLOPT_VALUE("SSLVERSION_TLSv1",CURL_SSLVERSION_TLSv1)
    CHECK_CURLOPT_VALUE("SSLVERSION_SSLv2",CURL_SSLVERSION_SSLv2)
    CHECK_CURLOPT_VALUE("SSLVERSION_SSLv3",CURL_SSLVERSION_SSLv3)
    CHECK_CURLOPT_VALUE("SSLVERSION_TLSv1_0",CURL_SSLVERSION_TLSv1_0)
    CHECK_CURLOPT_VALUE("SSLVERSION_TLSv1_1",CURL_SSLVERSION_TLSv1_1)
    CHECK_CURLOPT_VALUE("SSLVERSION_TLSv1_2",CURL_SSLVERSION_TLSv1_2)
    CHECK_CURLOPT_VALUE("SSLVERSION_TLSv1_3",CURL_SSLVERSION_TLSv1_3)
    CHECK_CURLOPT_VALUE("SSLVERSION_MAX_DEFAULT",CURL_SSLVERSION_MAX_DEFAULT)
    CHECK_CURLOPT_VALUE("SSLVERSION_MAX_TLSv1_0",CURL_SSLVERSION_MAX_TLSv1_0)
    CHECK_CURLOPT_VALUE("SSLVERSION_MAX_TLSv1_1",CURL_SSLVERSION_MAX_TLSv1_1)
    CHECK_CURLOPT_VALUE("SSLVERSION_MAX_TLSv1_2",CURL_SSLVERSION_MAX_TLSv1_2)
    CHECK_CURLOPT_VALUE("SSLVERSION_MAX_TLSv1_3",CURL_SSLVERSION_MAX_TLSv1_3)
    
    /* HEADEROPT */
    CHECK_CURLOPT_VALUE("HEADER_UNIFIED",CURLHEADER_UNIFIED)
    CHECK_CURLOPT_VALUE("HEADER_SEPARATE",CURLHEADER_SEPARATE)
    
    /* HTTP_VERSION */
    CHECK_CURLOPT_VALUE("HTTP_VERSION_NONE",CURL_HTTP_VERSION_NONE)
    CHECK_CURLOPT_VALUE("HTTP_VERSION_1_0",CURL_HTTP_VERSION_1_0)
    CHECK_CURLOPT_VALUE("HTTP_VERSION_1_1",CURL_HTTP_VERSION_1_1)
    CHECK_CURLOPT_VALUE("HTTP_VERSION_2",CURL_HTTP_VERSION_2)
    CHECK_CURLOPT_VALUE("HTTP_VERSION_2TLS",CURL_HTTP_VERSION_2TLS)
    CHECK_CURLOPT_VALUE("HTTP_VERSION_2_PRIOR_KNOWLEDGE",CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE)

    /* TIMECONDITION */
    CHECK_CURLOPT_VALUE("TIMECOND_IFMODSINCE",CURL_TIMECOND_IFMODSINCE)
    CHECK_CURLOPT_VALUE("TIMECOND_IFUNMODSINCE",CURL_TIMECOND_IFUNMODSINCE)
    CHECK_CURLOPT_VALUE("TIMECOND_LASTMOD",CURL_TIMECOND_LASTMOD)

    /* PROXYTYPE */
    CHECK_CURLOPT_VALUE("PROXY_HTTPS",CURLPROXY_HTTPS)
    CHECK_CURLOPT_VALUE("PROXY_SOCKS4",CURLPROXY_SOCKS4)
    CHECK_CURLOPT_VALUE("PROXY_SOCKS4A",CURLPROXY_SOCKS4A)
    CHECK_CURLOPT_VALUE("PROXY_SOCKS5",CURLPROXY_SOCKS5)

    /* FTPSSLAUTH */
    CHECK_CURLOPT_VALUE("FTPAUTH_SSL",CURLFTPAUTH_SSL)
    CHECK_CURLOPT_VALUE("FTPAUTH_TLS",CURLFTPAUTH_TLS)
    
    json_get_curl_option_value_exit:
    
    curl_easy_setopt(curl, option, v);
}

static void curl_easy_setopt_array(CURL *curl, CURLoption option, PA_CollectionRef col, struct curl_slist *list) {
    
    if(col) {
        
        for(PA_long32 i =0; i < PA_GetCollectionLength(col); ++i) {
            PA_Variable v = PA_GetCollectionElement(col, i);
            if(PA_GetVariableKind(v) == eVK_Unistring){
                PA_Unistring u = PA_GetStringVariable(v);
                CUTF16String u16value = CUTF16String(u.fString, u.fLength);
                std::string stringValue;
                convert_unistring_to_string(u16value, stringValue);
                if(stringValue.length()) {
                    list = curl_slist_append(list, stringValue.c_str());
                }
            }
        }
        if(list)
            curl_easy_setopt(curl, option, list);
    }
}

static void curl_easy_setopt_path(CURL *curl, CURLoption option, CUTF8String& stringValue) {
    
#if VERSIONMAC
    /* hfs to posix */
    C_TEXT t;
    t.setUTF8String((const uint8_t *)stringValue.c_str(), (uint32_t)stringValue.length());
    CUTF8String u;
    t.copyPath(&u);
    curl_easy_setopt(curl, option, (const char *)u.c_str());
#else
    curl_easy_setopt(curl, option, stringValue.c_str());
#endif
}

static bool curl_set_options(CURL *curl,
                             PA_ObjectRef Param1,
                             CPathString& request_path,
                             CPathString& response_path,
                             C_TEXT& userInfo,
                             struct curl_slist *curl_slist_connect_to,
                             struct curl_slist *curl_slist_proxy_header,
                             struct curl_slist *curl_slist_http_header,
                             struct curl_slist *curl_slist_http_200_aliases,
                             struct curl_slist *curl_slist_resolve,
                             struct curl_slist *curl_slist_mail_rcpt,
                             struct curl_slist *curl_slist_mail_from,
                             struct curl_slist *curl_slist_prequote,
                             struct curl_slist *curl_slist_postquote,
                             struct curl_slist *curl_slist_quote,
                             struct curl_slist *curl_slist_telnet_options)
{
    bool isAtomic = FALSE;
    
    if(Param1) {
        
        CUTF8String url;
        
        if(ob_is_defined(Param1, L"URL")) {
            if(ob_get_s(Param1, L"URL", &url)) {
                if(url.length())
                {
                    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
                }
            }
        }
        
        CUTF8String stringValue;
        
        /* special string */
        
        if(ob_get_s(Param1, L"READDATA", &stringValue)) {
#if VERSIONMAC
                        C_TEXT t;
                        t.setUTF8String(stringValue.c_str(), (uint32_t)stringValue.length());
                        CUTF8String _path;
                        t.copyPath(&_path);
                        request_path = (const uint8_t *)_path.c_str();
#else
                        C_TEXT t;
                        t.setUTF8String((const uint8_t *)stringValue.c_str(), stringValue.length());
                        CUTF16String _path;
                        t.copyUTF16String(&_path);
                        request_path = (const PA_Unichar *)_path.c_str();
#endif
        }
        
        if(ob_get_s(Param1, L"WRITEDATA", &stringValue)) {
#if VERSIONMAC
                        C_TEXT t;
                        t.setUTF8String(stringValue.c_str(), (uint32_t)stringValue.length());
                        CUTF8String _path;
                        t.copyPath(&_path);
                        response_path = (const uint8_t *)_path.c_str();
#else
                        C_TEXT t;
                        t.setUTF8String((const uint8_t *)stringValue.c_str(), stringValue.length());
                        CUTF16String _path;
                        t.copyUTF16String(&_path);
                        response_path = (const PA_Unichar *)_path.c_str();
#endif
        }
        
        if(ob_get_s(Param1, L"AUTOPROXY", &stringValue)) {
            
            std::lock_guard<std::mutex> lock(mutexPf);
            
            char **proxies = px_proxy_factory_get_proxies(pf, (const char *)url.c_str());
            
            if(proxies)
            {
                for (unsigned int j = 0; proxies[j]; ++j)
                {
                    if (!strncmp("direct://", proxies[j], 9))
                        continue;
                    
                    curl_easy_setopt(curl, CURLOPT_PROXY, proxies[j]);
                    
                    if (!strncmp("https", proxies[j], 5))
                        curl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_HTTPS);
                    
                    else if (!strncmp("http", proxies[j], 4))
                        curl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);
                    
                    else if (!strncmp("socks4", proxies[j], 5))
                        curl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS4);
                    
                    else if (!strncmp("socks5", proxies[j], 5))
                        curl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5);
                }
                
            }
            px_proxy_factory_free_proxies(proxies);

        }
        
        if(ob_get_s(Param1, L"PRIVATE", &stringValue)) {
            userInfo.setUTF8String(stringValue.c_str(), (uint32_t)stringValue.length());
        }
        
        if(ob_is_defined(Param1, L"ATOMIC")) {
            isAtomic = ob_get_b(Param1, L"ATOMIC");
        }
        
        /* string */
        
        if(ob_get_s(Param1, L"PROXY", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXY, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"USERPWD", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_USERPWD, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXYUSERPWD", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"RANGE", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_RANGE, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"REFERER", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_REFERER, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"FTPPORT", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_FTPPORT, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"USERAGENT", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_USERAGENT, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"COOKIE", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_COOKIE, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"KEYPASSWD", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_KEYPASSWD, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"CUSTOMREQUEST", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"INTERFACE", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_INTERFACE, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"KRBLEVEL", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_KRBLEVEL, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"RANDOM_FILE", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_RANDOM_FILE, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"EGDSOCKET", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_EGDSOCKET, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"SSL_CIPHER_LIST", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_SSL_CIPHER_LIST, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"SSLCERTTYPE", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"SSLKEYTYPE", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"ACCEPT_ENCODING", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_ACCEPT_ENCODING, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"FTP_ACCOUNT", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_FTP_ACCOUNT, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"COOKIELIST", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_COOKIELIST, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"FTP_ALTERNATIVE_TO_USER", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_FTP_ALTERNATIVE_TO_USER, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"SSH_HOST_PUBLIC_KEY_MD5", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"USERNAME", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_USERNAME, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PASSWORD", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PASSWORD, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXYUSERNAME", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXYUSERNAME, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXYPASSWORD", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXYPASSWORD, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"NOPROXY", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_NOPROXY, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"SSH_KNOWNHOSTS", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_SSH_KNOWNHOSTS, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"RTSP_SESSION_ID", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_RTSP_SESSION_ID, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"RTSP_STREAM_URI", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_RTSP_STREAM_URI, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"RTSP_TRANSPORT", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_RTSP_TRANSPORT, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"TLSAUTH_USERNAME", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_TLSAUTH_USERNAME, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"TLSAUTH_PASSWORD", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_TLSAUTH_PASSWORD, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"TLSAUTH_TYPE", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_TLSAUTH_TYPE, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"DNS_SERVERS", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_DNS_SERVERS, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"MAIL_AUTH", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_MAIL_AUTH, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"XOAUTH2_BEARER", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_XOAUTH2_BEARER, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"DNS_INTERFACE", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_DNS_INTERFACE, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"DNS_LOCAL_IP4", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_DNS_LOCAL_IP4, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"DNS_LOCAL_IP6", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_DNS_LOCAL_IP6, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"LOGIN_OPTIONS", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_LOGIN_OPTIONS, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXY_SERVICE_NAME", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXY_SERVICE_NAME, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"SERVICE_NAME", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_SERVICE_NAME, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"DEFAULT_PROTOCOL", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_DEFAULT_PROTOCOL, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXY_TLSAUTH_USERNAME", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXY_TLSAUTH_USERNAME, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXY_TLSAUTH_PASSWORD", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXY_TLSAUTH_PASSWORD, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXY_TLSAUTH_TYPE", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXY_TLSAUTH_TYPE, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXY_SSLCERTTYPE", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXY_SSLCERTTYPE, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXY_SSLKEYTYPE", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXY_SSLKEYTYPE, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXY_KEYPASSWD", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXY_KEYPASSWD, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXY_SSL_CIPHER_LIST", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXY_SSL_CIPHER_LIST, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PRE_PROXY", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PRE_PROXY, stringValue.c_str());
        }
                
        if(ob_get_s(Param1, L"REQUEST_TARGET", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_REQUEST_TARGET, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"TLS13_CIPHERS", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_TLS13_CIPHERS, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"PROXY_TLS13_CIPHERS", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_PROXY_TLS13_CIPHERS, stringValue.c_str());
        }
        
        if(ob_get_s(Param1, L"DOH_URL", &stringValue)) {
            curl_easy_setopt(curl, CURLOPT_DOH_URL, stringValue.c_str());
        }
        
        /* path */
        
        if(ob_get_s(Param1, L"SSLCERT", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_SSLCERT, stringValue);
        }
        
        if(ob_get_s(Param1, L"COOKIEFILE", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_COOKIEFILE, stringValue);
        }
        
        if(ob_get_s(Param1, L"CAINFO", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_CAINFO, stringValue);
        }
        
        if(ob_get_s(Param1, L"COOKIEJAR", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_COOKIEJAR, stringValue);
        }
        
        if(ob_get_s(Param1, L"SSLKEY", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_SSLKEY, stringValue);
        }
        
        if(ob_get_s(Param1, L"CAPATH", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_CAPATH, stringValue);
        }
        
        if(ob_get_s(Param1, L"NETRC_FILE", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_NETRC_FILE, stringValue);
        }
        
        if(ob_get_s(Param1, L"SSH_PUBLIC_KEYFILE", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_SSH_PUBLIC_KEYFILE, stringValue);
        }
        
        if(ob_get_s(Param1, L"SSH_PRIVATE_KEYFILE", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_SSH_PRIVATE_KEYFILE, stringValue);
        }
        
        if(ob_get_s(Param1, L"CRLFILE", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_CRLFILE, stringValue);
        }
        
        if(ob_get_s(Param1, L"ISSUERCERT", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_ISSUERCERT, stringValue);
        }
        
        if(ob_get_s(Param1, L"PROXY_CAINFO", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_PROXY_CAINFO, stringValue);
        }
        
        if(ob_get_s(Param1, L"PROXY_CAPATH", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_PROXY_CAPATH, stringValue);
        }
        
        if(ob_get_s(Param1, L"PROXY_SSLCERT", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_PROXY_SSLCERT, stringValue);
        }

        if(ob_get_s(Param1, L"PROXY_SSLKEY", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_PROXY_SSLKEY, stringValue);
        }
        
        if(ob_get_s(Param1, L"PROXY_CRLFILE", &stringValue)) {
            curl_easy_setopt_path(curl, CURLOPT_PROXY_CRLFILE, stringValue);
        }
        
        /* longint */
        
        if(ob_is_defined(Param1, L"PORT")) {
            curl_easy_setopt(curl, CURLOPT_PORT, (long)ob_get_n(Param1, L"PORT"));
        }
        
        if(ob_is_defined(Param1, L"TIMEOUT")) {
            curl_easy_setopt(curl, CURLOPT_TIMEOUT, (long)ob_get_n(Param1, L"TIMEOUT"));
        }
        if(ob_is_defined(Param1, L"LOW_SPEED_LIMIT")) {
            curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, (long)ob_get_n(Param1, L"LOW_SPEED_LIMIT"));
        }
        if(ob_is_defined(Param1, L"LOW_SPEED_TIME")) {
            curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, (long)ob_get_n(Param1, L"LOW_SPEED_TIME"));
        }
        if(ob_is_defined(Param1, L"RESUME_FROM")) {
            curl_easy_setopt(curl, CURLOPT_RESUME_FROM_LARGE, (curl_off_t)ob_get_n(Param1, L"RESUME_FROM"));
        }
        if(ob_is_defined(Param1, L"RESUME_FROM_LARGE")) {
            curl_easy_setopt(curl, CURLOPT_RESUME_FROM_LARGE, (curl_off_t)ob_get_n(Param1, L"RESUME_FROM_LARGE"));
        }
        if(ob_is_defined(Param1, L"CRLF")) {
            curl_easy_setopt(curl, CURLOPT_CRLF, (long)ob_get_n(Param1, L"CRLF"));
        }
        if(ob_is_defined(Param1, L"TIMEVALUE")) {
            curl_easy_setopt(curl, CURLOPT_TIMEVALUE_LARGE, (curl_off_t)ob_get_n(Param1, L"TIMEVALUE"));
        }
        if(ob_is_defined(Param1, L"TIMEVALUE_LARGE")) {
            curl_easy_setopt(curl, CURLOPT_TIMEVALUE_LARGE, (curl_off_t)ob_get_n(Param1, L"TIMEVALUE_LARGE"));
        }
        if(ob_is_defined(Param1, L"HEADER")) {
            curl_easy_setopt(curl, CURLOPT_HEADER, (long)ob_get_n(Param1, L"HEADER"));
        }
        if(ob_is_defined(Param1, L"NOBODY")) {
            curl_easy_setopt(curl, CURLOPT_NOBODY, (long)ob_get_n(Param1, L"NOBODY"));
        }
        if(ob_is_defined(Param1, L"FAILONERROR")) {
            curl_easy_setopt(curl, CURLOPT_FAILONERROR, (long)ob_get_n(Param1, L"FAILONERROR"));
        }
        if(ob_is_defined(Param1, L"UPLOAD")) {
            curl_easy_setopt(curl, CURLOPT_UPLOAD, (long)ob_get_n(Param1, L"UPLOAD"));
        }
        if(ob_is_defined(Param1, L"POST")) {
            curl_easy_setopt(curl, CURLOPT_POST, (long)ob_get_n(Param1, L"POST"));
        }
        if(ob_is_defined(Param1, L"DIRLISTONLY")) {
            curl_easy_setopt(curl, CURLOPT_DIRLISTONLY, (long)ob_get_n(Param1, L"DIRLISTONLY"));
        }
        if(ob_is_defined(Param1, L"APPEND")) {
            curl_easy_setopt(curl, CURLOPT_APPEND, (long)ob_get_n(Param1, L"APPEND"));
        }
        if(ob_is_defined(Param1, L"NETRC")) {
            curl_easy_setopt(curl, CURLOPT_NETRC, (long)ob_get_n(Param1, L"NETRC"));
        }
        if(ob_is_defined(Param1, L"FOLLOWLOCATION")) {
            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, (long)ob_get_n(Param1, L"FOLLOWLOCATION"));
        }
        if(ob_is_defined(Param1, L"PUT")) {
            curl_easy_setopt(curl, CURLOPT_PUT, (long)ob_get_n(Param1, L"PUT"));
        }
        if(ob_is_defined(Param1, L"AUTOREFERER")) {
            curl_easy_setopt(curl, CURLOPT_AUTOREFERER, (long)ob_get_n(Param1, L"AUTOREFERER"));
        }
        if(ob_is_defined(Param1, L"PROXYPORT")) {
            curl_easy_setopt(curl, CURLOPT_PROXYPORT, (long)ob_get_n(Param1, L"PROXYPORT"));
        }
        if(ob_is_defined(Param1, L"HTTPPROXYTUNNEL")) {
            curl_easy_setopt(curl, CURLOPT_HTTPPROXYTUNNEL, (long)ob_get_n(Param1, L"HTTPPROXYTUNNEL"));
        }
        if(ob_is_defined(Param1, L"SSL_VERIFYPEER")) {
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, (long)ob_get_n(Param1, L"SSL_VERIFYPEER"));
        }
        if(ob_is_defined(Param1, L"MAXREDIRS")) {
            curl_easy_setopt(curl, CURLOPT_MAXREDIRS, (long)ob_get_n(Param1, L"MAXREDIRS"));
        }
        if(ob_is_defined(Param1, L"FILETIME")) {
            curl_easy_setopt(curl, CURLOPT_FILETIME, (long)ob_get_n(Param1, L"FILETIME"));
        }
        if(ob_is_defined(Param1, L"MAXCONNECTS")) {
            curl_easy_setopt(curl, CURLOPT_MAXCONNECTS, (long)ob_get_n(Param1, L"MAXCONNECTS"));
        }
        if(ob_is_defined(Param1, L"FRESH_CONNECT")) {
            curl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, (long)ob_get_n(Param1, L"FRESH_CONNECT"));
        }
        if(ob_is_defined(Param1, L"FORBID_REUSE")) {
            curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, (long)ob_get_n(Param1, L"FORBID_REUSE"));
        }
        if(ob_is_defined(Param1, L"CONNECTTIMEOUT")) {
            curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, (long)ob_get_n(Param1, L"CONNECTTIMEOUT"));
        }
        if(ob_is_defined(Param1, L"HTTPGET")) {
            curl_easy_setopt(curl, CURLOPT_HTTPGET, (long)ob_get_n(Param1, L"HTTPGET"));
        }
        if(ob_is_defined(Param1, L"SSL_VERIFYHOST")) {
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, (long)ob_get_n(Param1, L"SSL_VERIFYHOST"));
        }
        if(ob_is_defined(Param1, L"FTP_USE_EPSV")) {
            curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV, (long)ob_get_n(Param1, L"FTP_USE_EPSV"));
        }
        if(ob_is_defined(Param1, L"DNS_CACHE_TIMEOUT")) {
            curl_easy_setopt(curl, CURLOPT_DNS_CACHE_TIMEOUT, (long)ob_get_n(Param1, L"DNS_CACHE_TIMEOUT"));
        }
        if(ob_is_defined(Param1, L"COOKIESESSION")) {
            curl_easy_setopt(curl, CURLOPT_COOKIESESSION, (long)ob_get_n(Param1, L"COOKIESESSION"));
        }
        if(ob_is_defined(Param1, L"BUFFERSIZE")) {
            curl_easy_setopt(curl, CURLOPT_BUFFERSIZE, (long)ob_get_n(Param1, L"BUFFERSIZE"));
        }
        if(ob_is_defined(Param1, L"UNRESTRICTED_AUTH")) {
            curl_easy_setopt(curl, CURLOPT_UNRESTRICTED_AUTH, (long)ob_get_n(Param1, L"UNRESTRICTED_AUTH"));
        }
        if(ob_is_defined(Param1, L"FTP_USE_EPRT")) {
            curl_easy_setopt(curl, CURLOPT_FTP_USE_EPRT, (long)ob_get_n(Param1, L"FTP_USE_EPRT"));
        }
        if(ob_is_defined(Param1, L"HTTPAUTH")) {
            curl_easy_setopt(curl, CURLOPT_HTTPAUTH, (long)ob_get_n(Param1, L"HTTPAUTH"));
        }
        if(ob_is_defined(Param1, L"FTP_CREATE_MISSING_DIRS")) {
            curl_easy_setopt(curl, CURLOPT_FTP_CREATE_MISSING_DIRS, (long)ob_get_n(Param1, L"FTP_CREATE_MISSING_DIRS"));
        }
        if(ob_is_defined(Param1, L"PROXYAUTH")) {
            curl_easy_setopt(curl, CURLOPT_PROXYAUTH, (long)ob_get_n(Param1, L"PROXYAUTH"));
        }
        if(ob_is_defined(Param1, L"FTP_RESPONSE_TIMEOUT")) {
            curl_easy_setopt(curl, CURLOPT_FTP_RESPONSE_TIMEOUT, (long)ob_get_n(Param1, L"FTP_RESPONSE_TIMEOUT"));
        }
        if(ob_is_defined(Param1, L"IPRESOLVE")) {
            curl_easy_setopt(curl, CURLOPT_IPRESOLVE, (long)ob_get_n(Param1, L"IPRESOLVE"));
        }
        if(ob_is_defined(Param1, L"MAXFILESIZE")) {
            curl_easy_setopt(curl, CURLOPT_MAXFILESIZE_LARGE, (curl_off_t)ob_get_n(Param1, L"MAXFILESIZE"));
        }
        if(ob_is_defined(Param1, L"MAXFILESIZE_LARGE")) {
            curl_easy_setopt(curl, CURLOPT_MAXFILESIZE_LARGE, (curl_off_t)ob_get_n(Param1, L"MAXFILESIZE_LARGE"));
        }
        if(ob_is_defined(Param1, L"IGNORE_CONTENT_LENGTH")) {
            curl_easy_setopt(curl, CURLOPT_IGNORE_CONTENT_LENGTH, (long)ob_get_n(Param1, L"IGNORE_CONTENT_LENGTH"));
        }
        if(ob_is_defined(Param1, L"FTP_SKIP_PASV_IP")) {
            curl_easy_setopt(curl, CURLOPT_FTP_SKIP_PASV_IP, (long)ob_get_n(Param1, L"FTP_SKIP_PASV_IP"));
        }
        if(ob_is_defined(Param1, L"FTP_FILEMETHOD")) {
            curl_easy_setopt(curl, CURLOPT_FTP_FILEMETHOD, (long)ob_get_n(Param1, L"FTP_FILEMETHOD"));
        }
        if(ob_is_defined(Param1, L"LOCALPORT")) {
            curl_easy_setopt(curl, CURLOPT_LOCALPORT, (long)ob_get_n(Param1, L"LOCALPORT"));
        }
        if(ob_is_defined(Param1, L"LOCALPORTRANGE")) {
            curl_easy_setopt(curl, CURLOPT_LOCALPORTRANGE, (long)ob_get_n(Param1, L"LOCALPORTRANGE"));
        }
        if(ob_is_defined(Param1, L"CONNECT_ONLY")) {
            curl_easy_setopt(curl, CURLOPT_CONNECT_ONLY, (long)ob_get_n(Param1, L"CONNECT_ONLY"));
        }
        if(ob_is_defined(Param1, L"SSL_SESSIONID_CACHE")) {
            curl_easy_setopt(curl, CURLOPT_SSL_SESSIONID_CACHE, (long)ob_get_n(Param1, L"SSL_SESSIONID_CACHE"));
        }
        
        long SSH_AUTH_TYPES = CURLSSH_AUTH_PUBLICKEY|CURLSSH_AUTH_PASSWORD;
        
        if(ob_is_defined(Param1, L"SSH_AUTH_TYPES")) {
            SSH_AUTH_TYPES = (long)ob_get_n(Param1, L"SSH_AUTH_TYPES");
        }
        //disable these
        SSH_AUTH_TYPES &= ~(CURLSSH_AUTH_KEYBOARD|CURLSSH_AUTH_AGENT);
        
        curl_easy_setopt(curl, CURLOPT_SSH_AUTH_TYPES, SSH_AUTH_TYPES);
        
        if(ob_is_defined(Param1, L"FTP_SSL_CCC")) {
            curl_easy_setopt(curl, CURLOPT_FTP_SSL_CCC, (long)ob_get_n(Param1, L"FTP_SSL_CCC"));
        }
        if(ob_is_defined(Param1, L"TIMEOUT_MS")) {
            curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, (long)ob_get_n(Param1, L"TIMEOUT_MS"));
        }
        if(ob_is_defined(Param1, L"CONNECTTIMEOUT_MS")) {
            curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, (long)ob_get_n(Param1, L"CONNECTTIMEOUT_MS"));
        }
        if(ob_is_defined(Param1, L"HTTP_TRANSFER_DECODING")) {
            curl_easy_setopt(curl, CURLOPT_HTTP_TRANSFER_DECODING, (long)ob_get_n(Param1, L"HTTP_TRANSFER_DECODING"));
        }
        if(ob_is_defined(Param1, L"HTTP_CONTENT_DECODING")) {
            curl_easy_setopt(curl, CURLOPT_HTTP_CONTENT_DECODING, (long)ob_get_n(Param1, L"HTTP_CONTENT_DECODING"));
        }
        if(ob_is_defined(Param1, L"NEW_FILE_PERMS")) {
            curl_easy_setopt(curl, CURLOPT_NEW_FILE_PERMS, (long)ob_get_n(Param1, L"NEW_FILE_PERMS"));
        }
        if(ob_is_defined(Param1, L"NEW_DIRECTORY_PERMS")) {
            curl_easy_setopt(curl, CURLOPT_NEW_DIRECTORY_PERMS, (long)ob_get_n(Param1, L"NEW_DIRECTORY_PERMS"));
        }
        if(ob_is_defined(Param1, L"POSTREDIR")) {
            curl_easy_setopt(curl, CURLOPT_POSTREDIR, (long)ob_get_n(Param1, L"POSTREDIR"));
        }
        if(ob_is_defined(Param1, L"PROXY_TRANSFER_MODE")) {
            curl_easy_setopt(curl, CURLOPT_PROXY_TRANSFER_MODE, (long)ob_get_n(Param1, L"PROXY_TRANSFER_MODE"));
        }
        if(ob_is_defined(Param1, L"ADDRESS_SCOPE")) {
            curl_easy_setopt(curl, CURLOPT_ADDRESS_SCOPE, (long)ob_get_n(Param1, L"ADDRESS_SCOPE"));
        }
        if(ob_is_defined(Param1, L"CERTINFO")) {
            curl_easy_setopt(curl, CURLOPT_CERTINFO, (long)ob_get_n(Param1, L"CERTINFO"));
        }
        if(ob_is_defined(Param1, L"TFTP_BLKSIZE")) {
            curl_easy_setopt(curl, CURLOPT_TFTP_BLKSIZE, (long)ob_get_n(Param1, L"TFTP_BLKSIZE"));
        }
        if(ob_is_defined(Param1, L"PROTOCOLS")) {
            curl_easy_setopt(curl, CURLOPT_PROTOCOLS, (long)ob_get_n(Param1, L"PROTOCOLS"));
        }
        if(ob_is_defined(Param1, L"REDIR_PROTOCOLS")) {
            curl_easy_setopt(curl, CURLOPT_REDIR_PROTOCOLS, (long)ob_get_n(Param1, L"REDIR_PROTOCOLS"));
        }
        if(ob_is_defined(Param1, L"FTP_USE_PRET")) {
            curl_easy_setopt(curl, CURLOPT_FTP_USE_PRET, (long)ob_get_n(Param1, L"FTP_USE_PRET"));
        }
        if(ob_is_defined(Param1, L"RTSP_REQUEST")) {
            curl_easy_setopt(curl, CURLOPT_RTSP_REQUEST, (long)ob_get_n(Param1, L"RTSP_REQUEST"));
        }
        if(ob_is_defined(Param1, L"RTSP_CLIENT_CSEQ")) {
            curl_easy_setopt(curl, CURLOPT_RTSP_CLIENT_CSEQ, (long)ob_get_n(Param1, L"RTSP_CLIENT_CSEQ"));
        }
        if(ob_is_defined(Param1, L"RTSP_SERVER_CSEQ")) {
            curl_easy_setopt(curl, CURLOPT_RTSP_SERVER_CSEQ, (long)ob_get_n(Param1, L"RTSP_SERVER_CSEQ"));
        }
        if(ob_is_defined(Param1, L"WILDCARDMATCH")) {
            curl_easy_setopt(curl, CURLOPT_WILDCARDMATCH, (long)ob_get_n(Param1, L"WILDCARDMATCH"));
        }
        if(ob_is_defined(Param1, L"TRANSFER_ENCODING")) {
            curl_easy_setopt(curl, CURLOPT_TRANSFER_ENCODING, (long)ob_get_n(Param1, L"TRANSFER_ENCODING"));
        }
        if(ob_is_defined(Param1, L"ACCEPTTIMEOUT_MS")) {
            curl_easy_setopt(curl, CURLOPT_ACCEPTTIMEOUT_MS, (long)ob_get_n(Param1, L"ACCEPTTIMEOUT_MS"));
        }
        if(ob_is_defined(Param1, L"TCP_KEEPALIVE")) {
            curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, (long)ob_get_n(Param1, L"TCP_KEEPALIVE"));
        }
        if(ob_is_defined(Param1, L"TCP_KEEPIDLE")) {
            curl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, (long)ob_get_n(Param1, L"TCP_KEEPIDLE"));
        }
        if(ob_is_defined(Param1, L"TCP_KEEPINTVL")) {
            curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, (long)ob_get_n(Param1, L"TCP_KEEPINTVL"));
        }
        if(ob_is_defined(Param1, L"SASL_IR")) {
            curl_easy_setopt(curl, CURLOPT_SASL_IR, (long)ob_get_n(Param1, L"SASL_IR"));
        }
        if(ob_is_defined(Param1, L"SSL_ENABLE_NPN")) {
            curl_easy_setopt(curl, CURLOPT_SSL_ENABLE_NPN, (long)ob_get_n(Param1, L"SSL_ENABLE_NPN"));
        }
        if(ob_is_defined(Param1, L"SSL_ENABLE_ALPN")) {
            curl_easy_setopt(curl, CURLOPT_SSL_ENABLE_ALPN, (long)ob_get_n(Param1, L"SSL_ENABLE_ALPN"));
        }
        if(ob_is_defined(Param1, L"EXPECT_100_TIMEOUT_MS")) {
            curl_easy_setopt(curl, CURLOPT_EXPECT_100_TIMEOUT_MS, (long)ob_get_n(Param1, L"EXPECT_100_TIMEOUT_MS"));
        }
        if(ob_is_defined(Param1, L"HEADEROPT")) {
            curl_easy_setopt(curl, CURLOPT_HEADEROPT, (long)ob_get_n(Param1, L"HEADEROPT"));
        }
        if(ob_is_defined(Param1, L"SSL_VERIFYSTATUS")) {
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYSTATUS, (long)ob_get_n(Param1, L"SSL_VERIFYSTATUS"));
        }
        if(ob_is_defined(Param1, L"SSL_FALSESTART")) {
            curl_easy_setopt(curl, CURLOPT_SSL_FALSESTART, (long)ob_get_n(Param1, L"SSL_FALSESTART"));
        }
        if(ob_is_defined(Param1, L"PATH_AS_IS")) {
            curl_easy_setopt(curl, CURLOPT_PATH_AS_IS, (long)ob_get_n(Param1, L"PATH_AS_IS"));
        }
        if(ob_is_defined(Param1, L"PIPEWAIT")) {
            curl_easy_setopt(curl, CURLOPT_PIPEWAIT, (long)ob_get_n(Param1, L"PIPEWAIT"));
        }
        if(ob_is_defined(Param1, L"STREAM_WEIGHT")) {
            curl_easy_setopt(curl, CURLOPT_STREAM_WEIGHT, (long)ob_get_n(Param1, L"STREAM_WEIGHT"));
        }
        if(ob_is_defined(Param1, L"TFTP_NO_OPTIONS")) {
            curl_easy_setopt(curl, CURLOPT_TFTP_NO_OPTIONS, (long)ob_get_n(Param1, L"TFTP_NO_OPTIONS"));
        }
        if(ob_is_defined(Param1, L"TCP_FASTOPEN")) {
            curl_easy_setopt(curl, CURLOPT_TCP_FASTOPEN, (long)ob_get_n(Param1, L"TCP_FASTOPEN"));
        }
        if(ob_is_defined(Param1, L"KEEP_SENDING_ON_ERROR")) {
            curl_easy_setopt(curl, CURLOPT_KEEP_SENDING_ON_ERROR, (long)ob_get_n(Param1, L"KEEP_SENDING_ON_ERROR"));
        }
        if(ob_is_defined(Param1, L"PROXY_SSL_VERIFYPEER")) {
            curl_easy_setopt(curl, CURLOPT_PROXY_SSL_VERIFYPEER, (long)ob_get_n(Param1, L"PROXY_SSL_VERIFYPEER"));
        }
        if(ob_is_defined(Param1, L"PROXY_SSL_VERIFYHOST")) {
            curl_easy_setopt(curl, CURLOPT_PROXY_SSL_VERIFYHOST, (long)ob_get_n(Param1, L"PROXY_SSL_VERIFYHOST"));
        }
        if(ob_is_defined(Param1, L"PROXY_SSL_OPTIONS")) {
            curl_easy_setopt(curl, CURLOPT_PROXY_SSL_OPTIONS, (long)ob_get_n(Param1, L"PROXY_SSL_OPTIONS"));
        }
        if(ob_is_defined(Param1, L"SUPPRESS_CONNECT_HEADERS")) {
            curl_easy_setopt(curl, CURLOPT_SUPPRESS_CONNECT_HEADERS, (long)ob_get_n(Param1, L"SUPPRESS_CONNECT_HEADERS"));
        }
        if(ob_is_defined(Param1, L"SOCKS5_AUTH")) {
            curl_easy_setopt(curl, CURLOPT_SOCKS5_AUTH, (long)ob_get_n(Param1, L"SOCKS5_AUTH"));
        }
        if(ob_is_defined(Param1, L"SSH_COMPRESSION")) {
            curl_easy_setopt(curl, CURLOPT_SSH_COMPRESSION, (long)ob_get_n(Param1, L"SSH_COMPRESSION"));
        }
        if(ob_is_defined(Param1, L"HAPPY_EYEBALLS_TIMEOUT_MS")) {
            curl_easy_setopt(curl, CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS, (long)ob_get_n(Param1, L"HAPPY_EYEBALLS_TIMEOUT_MS"));
        }
        if(ob_is_defined(Param1, L"HAPROXYPROTOCOL")) {
            curl_easy_setopt(curl, CURLOPT_HAPROXYPROTOCOL, (long)ob_get_n(Param1, L"HAPROXYPROTOCOL"));
        }
        if(ob_is_defined(Param1, L"DNS_SHUFFLE_ADDRESSES")) {
            curl_easy_setopt(curl, CURLOPT_DNS_SHUFFLE_ADDRESSES, (long)ob_get_n(Param1, L"DNS_SHUFFLE_ADDRESSES"));
        }
        if(ob_is_defined(Param1, L"DISALLOW_USERNAME_IN_URL")) {
            curl_easy_setopt(curl, CURLOPT_DISALLOW_USERNAME_IN_URL, (long)ob_get_n(Param1, L"DISALLOW_USERNAME_IN_URL"));
        }
        if(ob_is_defined(Param1, L"UPLOAD_BUFFERSIZE")) {
            curl_easy_setopt(curl, CURLOPT_UPLOAD_BUFFERSIZE, (long)ob_get_n(Param1, L"UPLOAD_BUFFERSIZE"));
        }
        if(ob_is_defined(Param1, L"MAX_SEND_SPEED")) {
            curl_easy_setopt(curl, CURLOPT_MAX_SEND_SPEED_LARGE, (curl_off_t)ob_get_n(Param1, L"MAX_SEND_SPEED"));
        }
        if(ob_is_defined(Param1, L"MAX_SEND_SPEED_LARGE")) {
            curl_easy_setopt(curl, CURLOPT_MAX_SEND_SPEED_LARGE, (curl_off_t)ob_get_n(Param1, L"MAX_SEND_SPEED_LARGE"));
        }
        if(ob_is_defined(Param1, L"MAX_RECV_SPEED")) {
            curl_easy_setopt(curl, CURLOPT_MAX_RECV_SPEED_LARGE, (curl_off_t)ob_get_n(Param1, L"MAX_RECV_SPEED"));
        }
        if(ob_is_defined(Param1, L"MAX_RECV_SPEED_LARGE")) {
            curl_easy_setopt(curl, CURLOPT_MAX_RECV_SPEED_LARGE, (curl_off_t)ob_get_n(Param1, L"MAX_RECV_SPEED_LARGE"));
        }
        
        
        
        
        if(ob_is_defined(Param1, L"UPKEEP_INTERVAL_MS")) {
            curl_easy_setopt(curl, CURLOPT_UPKEEP_INTERVAL_MS, (long)ob_get_n(Param1, L"UPKEEP_INTERVAL_MS"));
        }
        
        if(ob_get_s(Param1, L"PINNEDPUBLICKEY", &stringValue)) {
            if (stringValue.find_first_of((const uint8_t *)"sha256//") == CUTF8String::npos)
            {
#if VERSIONMAC
                /* hfs to posix */
                C_TEXT t;
                t.setUTF8String(stringValue.c_str(), (uint32_t)stringValue.length());
                CUTF8String u;
                t.copyPath(&u);
                curl_easy_setopt(curl, CURLOPT_PINNEDPUBLICKEY, (const char *)u.c_str());
#else
                curl_easy_setopt(curl, CURLOPT_PINNEDPUBLICKEY, stringValue.c_str());
#endif
            }else
            {
                curl_easy_setopt(curl, CURLOPT_PINNEDPUBLICKEY, stringValue.c_str());
            }
            
        }
        
        if(ob_get_s(Param1, L"PROXY_PINNEDPUBLICKEY", &stringValue)) {
            if (stringValue.find_first_of((const uint8_t *)"sha256//") == CUTF8String::npos)
            {
#if VERSIONMAC
                /* hfs to posix */
                C_TEXT t;
                t.setUTF8String(stringValue.c_str(), (uint32_t)stringValue.length());
                CUTF8String u;
                t.copyPath(&u);
                curl_easy_setopt(curl, CURLOPT_PROXY_PINNEDPUBLICKEY, (const char *)u.c_str());
#else
                curl_easy_setopt(curl, CURLOPT_PROXY_PINNEDPUBLICKEY, stringValue.c_str());
#endif
            }else
            {
                curl_easy_setopt(curl, CURLOPT_PROXY_PINNEDPUBLICKEY, stringValue.c_str());
            }
            
        }
        
        if(ob_get_s(Param1, L"USE_SSL", &stringValue)) {
            curl_easy_setopt_enum(curl, CURLOPT_USE_SSL, stringValue);
        }else if(ob_is_defined(Param1, L"USE_SSL")) {
            curl_easy_setopt(curl, CURLOPT_USE_SSL, ob_get_n(Param1, L"USE_SSL"));
        }

        if(ob_get_s(Param1, L"SSLVERSION", &stringValue)) {
            curl_easy_setopt_enum(curl, CURLOPT_SSLVERSION, stringValue);
        }else if(ob_is_defined(Param1, L"SSLVERSION")) {
            curl_easy_setopt(curl, CURLOPT_SSLVERSION, ob_get_n(Param1, L"SSLVERSION"));
        }
        
        if(ob_get_s(Param1, L"HTTP_VERSION", &stringValue)) {
            curl_easy_setopt_enum(curl, CURLOPT_HTTP_VERSION, stringValue);
        }else if(ob_is_defined(Param1, L"HTTP_VERSION")) {
            curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, ob_get_n(Param1, L"HTTP_VERSION"));
        }
        
        if(ob_get_s(Param1, L"PROXY_SSLVERSION", &stringValue)) {
            curl_easy_setopt_enum(curl, CURLOPT_PROXY_SSLVERSION, stringValue);
        }else if(ob_is_defined(Param1, L"PROXY_SSLVERSION")) {
            curl_easy_setopt(curl, CURLOPT_PROXY_SSLVERSION, ob_get_n(Param1, L"PROXY_SSLVERSION"));
        }
        
        if(ob_get_s(Param1, L"TIMECONDITION", &stringValue)) {
            curl_easy_setopt_enum(curl, CURLOPT_TIMECONDITION, stringValue);
        }else if(ob_is_defined(Param1, L"TIMECONDITION")) {
            curl_easy_setopt(curl, CURLOPT_TIMECONDITION, ob_get_n(Param1, L"TIMECONDITION"));
        }
        
        if(ob_get_s(Param1, L"PROXYTYPE", &stringValue)) {
            curl_easy_setopt_enum(curl, CURLOPT_PROXYTYPE, stringValue);
        }else if(ob_is_defined(Param1, L"PROXYTYPE")) {
            curl_easy_setopt(curl, CURLOPT_PROXYTYPE, ob_get_n(Param1, L"PROXYTYPE"));
        }
        
        if(ob_get_s(Param1, L"FTPSSLAUTH", &stringValue)) {
            curl_easy_setopt_enum(curl, CURLOPT_FTPSSLAUTH, stringValue);
        }else if(ob_is_defined(Param1, L"FTPSSLAUTH")) {
            curl_easy_setopt(curl, CURLOPT_FTPSSLAUTH, ob_get_n(Param1, L"FTPSSLAUTH"));
        }
        
        if(ob_get_s(Param1, L"HEADEROPT", &stringValue)) {
            curl_easy_setopt_enum(curl, CURLOPT_HEADEROPT, stringValue);
        }else if(ob_is_defined(Param1, L"HEADEROPT")) {
            curl_easy_setopt(curl, CURLOPT_HEADEROPT, ob_get_n(Param1, L"HEADEROPT"));
        }
        
        /* array string */
        
//        if(curl_slist_connect_to) {
            if(ob_is_defined(Param1, L"CONNECT_TO")) {
                curl_easy_setopt_array(curl, CURLOPT_CONNECT_TO, ob_get_c(Param1, L"CONNECT_TO"), curl_slist_connect_to);
            }
//        }

//        if(curl_slist_proxy_header) {
            if(ob_is_defined(Param1, L"PROXYHEADER")) {
                curl_easy_setopt_array(curl, CURLOPT_PROXYHEADER, ob_get_c(Param1, L"PROXYHEADER"), curl_slist_proxy_header);
            }
//        }
        
//        if(curl_slist_http_header) {
            if(ob_is_defined(Param1, L"HTTPHEADER")) {
                curl_easy_setopt_array(curl, CURLOPT_HTTPHEADER, ob_get_c(Param1, L"HTTPHEADER"), curl_slist_http_header);
            }
//        }

//        if(curl_slist_http_200_aliases) {
            if(ob_is_defined(Param1, L"HTTP200ALIASES")) {
                curl_easy_setopt_array(curl, CURLOPT_HTTP200ALIASES, ob_get_c(Param1, L"HTTP200ALIASES"), curl_slist_http_200_aliases);
            }
//        }
        
//        if(curl_slist_resolve) {
            if(ob_is_defined(Param1, L"RESOLVE")) {
                curl_easy_setopt_array(curl, CURLOPT_RESOLVE, ob_get_c(Param1, L"RESOLVE"), curl_slist_resolve);
            }
//        }

//        if(curl_slist_mail_rcpt) {
            if(ob_is_defined(Param1, L"MAIL_RCPT")) {
                curl_easy_setopt_array(curl, CURLOPT_MAIL_RCPT, ob_get_c(Param1, L"MAIL_RCPT"), curl_slist_mail_rcpt);
            }
//        }
        
//        if(curl_slist_prequote) {
            if(ob_is_defined(Param1, L"PREQUOTE")) {
                curl_easy_setopt_array(curl, CURLOPT_PREQUOTE, ob_get_c(Param1, L"PREQUOTE"), curl_slist_prequote);
            }
//        }

//        if(curl_slist_postquote) {
            if(ob_is_defined(Param1, L"POSTQUOTE")) {
                curl_easy_setopt_array(curl, CURLOPT_POSTQUOTE, ob_get_c(Param1, L"POSTQUOTE"), curl_slist_postquote);
            }
//        }

//        if(curl_slist_quote) {
            if(ob_is_defined(Param1, L"QUOTE")) {
                curl_easy_setopt_array(curl, CURLOPT_QUOTE, ob_get_c(Param1, L"QUOTE"), curl_slist_quote);
            }
//        }

//        if(curl_slist_telnet_options) {
            if(ob_is_defined(Param1, L"TELNETOPTIONS")) {
                curl_easy_setopt_array(curl, CURLOPT_TELNETOPTIONS, ob_get_c(Param1, L"TELNETOPTIONS"), curl_slist_telnet_options);
            }
//        }
    }
    return isAtomic;
}

static bool curl_set_debug_option(CURL *curl,
                                PA_ObjectRef Param1,
                                CPathString& debug_folder_path) {
  
    bool isDebugEnabled = FALSE;
    
    if(Param1) {
        
        if(ob_is_defined(Param1, L"DEBUG")) {
            
            CUTF8String path;
            if(ob_get_s(Param1, L"DEBUG", &path)){
            
                if(path.length())
                {
                    C_TEXT t;
                    t.setUTF8String((const uint8_t *)path.c_str(), (uint32_t)path.length());
#if VERSIONMAC
                    CUTF8String _path;
                    t.copyPath(&_path);
                    debug_folder_path = (const uint8_t *)_path.c_str();
                    if(debug_folder_path.at(debug_folder_path.size() - 1) != '/') debug_folder_path += '/';
#else
                    CUTF16String _path;
                    t.copyUTF16String(&_path);
                    debug_folder_path = (const PA_Unichar *)_path.c_str();
                    if(debug_folder_path.at(debug_folder_path.size() - 1) != L'\\') debug_folder_path += L'\\';
#endif
                    isDebugEnabled = TRUE;
                }
            }
        }
    }
    return isDebugEnabled;
}

void _cURL(PA_PluginParameters params) {

    PA_ObjectRef Param1 = PA_GetObjectParameter(params, 1); /* options */

    C_BLOB Param3; /* response */
    C_BLOB Param7;/* headerInfo */
    PA_ObjectRef returnValue  = PA_CreateObject();
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    C_BLOB Param2; /* request */
    Param2.fromParamAtIndex(pParams, 2);
    C_TEXT Param4; /* callbackMethod */
    Param4.fromParamAtIndex(pParams, 4);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;
    
    struct curl_slist *curl_slist_connect_to = NULL;/* CONNECT_TO */
    struct curl_slist *curl_slist_proxy_header = NULL;/* PROXYHEADER */
    struct curl_slist *curl_slist_http_header = NULL;/* HTTPHEADER */
    struct curl_slist *curl_slist_http_200_aliases = NULL;/* HTTP200ALIASES */
    struct curl_slist *curl_slist_resolve = NULL;/* RESOLVE */
    struct curl_slist *curl_slist_mail_rcpt = NULL;/* MAIL_RCPT */
    struct curl_slist *curl_slist_mail_from = NULL;/* MAIL_FROM */
    struct curl_slist *curl_slist_prequote = NULL;/* PREQUOTE */
    struct curl_slist *curl_slist_postquote = NULL;/* POSTQUOTE */
    struct curl_slist *curl_slist_quote = NULL;/* QUOTE */
    struct curl_slist *curl_slist_telnet_options = NULL;/* TELNETOPTIONS */
    
    C_TEXT userInfo; /* PRIVATE */
    
    CPathString request_path;
    CPathString response_path;
    
    bool isAtomic = curl_set_options(curl,
                                     Param1,
                                     request_path,
                                     response_path,
                                     userInfo,
                                     curl_slist_connect_to,
                                     curl_slist_proxy_header,
                                     curl_slist_http_header,
                                     curl_slist_http_200_aliases,
                                     curl_slist_resolve,
                                     curl_slist_mail_rcpt,
                                     curl_slist_mail_from,
                                     curl_slist_prequote,
                                     curl_slist_postquote,
                                     curl_slist_quote,
                                     curl_slist_telnet_options);
  
    http_ctx request_ctx;
    request_ctx.pos = 0L;
    request_ctx.data = &Param2; /* request */
    request_ctx.size = 0L;
    request_ctx.use_path = false;
    
    http_ctx response_ctx;
    response_ctx.pos = 0L;
    response_ctx.data = &Param3;/* response */
    response_ctx.size = 0L;
    response_ctx.use_path = false;
    
    http_ctx header_ctx;
    header_ctx.pos = 0L;
    header_ctx.data = &Param7;/* headerInfo */
    header_ctx.size = 0L;
    header_ctx.use_path = false;
    
    http_debug_ctx debug_ctx;
    
    debug_ctx.size_CURLINFO_TEXT = 0L;
    debug_ctx.size_CURLINFO_HEADER_IN = 0L;
    debug_ctx.size_CURLINFO_HEADER_OUT = 0L;
    debug_ctx.size_CURLINFO_DATA_IN = 0L;
    debug_ctx.size_CURLINFO_DATA_OUT = 0L;
    debug_ctx.size_CURLINFO_SSL_DATA_IN = 0L;
    debug_ctx.size_CURLINFO_SSL_DATA_OUT = 0L;
    
    CPathString debug_folder_path;
    
    if(curl_set_debug_option(curl,
                             Param1 /* options */,
                             debug_folder_path))
    {
#if VERSIONMAC
        debug_ctx.path = (const char *)debug_folder_path.c_str();
#else
        debug_ctx.path = (const wchar_t *)debug_folder_path.c_str();
#endif
        
        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);
        curl_easy_setopt(curl, CURLOPT_DEBUGDATA, &debug_ctx);
        curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, curl_debug_function);
    }

#if VERSIONMAC
    request_ctx.path = (const char *)request_path.c_str();
    response_ctx.path = (const char *)response_path.c_str();
#else
    request_ctx.path = (const wchar_t *)request_path.c_str();
    response_ctx.path = (const wchar_t *)response_path.c_str();
#endif
    
    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, (curl_off_t)Param2.getBytesLength());
    curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, (curl_off_t)Param2.getBytesLength());
    FILE *f = CPathOpen (request_ctx.path, CPathRead);
    if(f)
    {
        fseek(f, 0L, SEEK_END);
        request_ctx.size = (curl_off_t)ftell(f);
        fclose(f);
        
        if(request_ctx.size != -1L)
        {
            curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, request_ctx.size);
            curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, request_ctx.size);
        }
    }
    
    response_ctx.use_path = response_path.length();
    
    curl_easy_setopt(curl, CURLOPT_READDATA, &request_ctx);
    curl_easy_setopt(curl, CURLOPT_READFUNCTION, curl_read_function);
    
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_ctx);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function);
    
    curl_easy_setopt(curl, CURLOPT_HEADERDATA, &header_ctx);
    curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, curl_header_function);
    
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);

    CURLcode status = CURLE_OK;
    
    if(isAtomic)
    {
        
        status = curl_perform_atomic(curl, returnValue);
        
    }else
    {
		CUTF16String methodName = (PA_Unichar *)Param4.getUTF16StringPtr();
        status = curl_perform_non_atomic(mcurl, curl, methodName, userInfo, returnValue);
    }
    
    ob_set_n(returnValue, "status", status);
    
    /* convert headerInfo Param7:BLOB to Param6:TEXT */
    std::string headerInfo = std::string((const char *)Param7.getBytesPtr(), Param7.getBytesLength());
    ob_set_s(returnValue, "headerInfo", headerInfo.c_str());
        
    /* cleanup */
    
    if(curl_slist_connect_to)
        curl_slist_free_all(curl_slist_connect_to);
    
    if(curl_slist_proxy_header)
        curl_slist_free_all(curl_slist_proxy_header);
    
    if(curl_slist_http_header)
        curl_slist_free_all(curl_slist_http_header);
    
    if(curl_slist_http_200_aliases)
        curl_slist_free_all(curl_slist_http_200_aliases);
    
    if(curl_slist_resolve)
        curl_slist_free_all(curl_slist_resolve);
    
    if(curl_slist_mail_rcpt)
        curl_slist_free_all(curl_slist_mail_rcpt);
    
    if(curl_slist_mail_from)
        curl_slist_free_all(curl_slist_mail_from);
    
    if(curl_slist_prequote)
        curl_slist_free_all(curl_slist_prequote);
    
    if(curl_slist_postquote)
        curl_slist_free_all(curl_slist_postquote);
    
    if(curl_slist_quote)
        curl_slist_free_all(curl_slist_quote);
    
    if(curl_slist_telnet_options)
        curl_slist_free_all(curl_slist_telnet_options);
    
    curl_easy_cleanup(curl);
    
    PA_SetBlobParameter(params, 3, (void*)Param3.getBytesPtr(), Param3.getBytesLength());
    
    PA_ReturnObject(params, returnValue);
}

static protocol_type_t curl_set_options_for_ftp(CURL *curl,
                                                PA_ObjectRef Param1,
                                                CPathString& request_path,
                                                CPathString& response_path,
                                                C_TEXT& userInfo,
                                                std::string& ie,
                                                std::string& oe,
                                                std::string& path,
                                                curl_ftp_command_t commandType,
                                                BOOL removeFileName = FALSE) {
    
    protocol_type_t protocol = PROTOCOL_TYPE_UNKNOWN;
    
    curl_set_options(curl, Param1, request_path, response_path, userInfo,
                     NULL, NULL, NULL, NULL,
                     NULL, NULL, NULL, NULL,
                     NULL, NULL, NULL);
    
    CUTF8String stringValue;
    
    if(ob_is_defined(Param1, L"ENCODING_IN")) {
        if(ob_get_s(Param1, L"ENCODING_IN", &stringValue)) {
            if(stringValue.length()){
                ie = std::string((const char *)stringValue.c_str(), stringValue.length());
            }
        }
    }
    
    if(ob_is_defined(Param1, L"ENCODING_OUT")) {
        if(ob_get_s(Param1, L"ENCODING_OUT", &stringValue)) {
            if(stringValue.length()){
                oe = std::string((const char *)stringValue.c_str(), stringValue.length());
            }
        }
    }
    
    CUTF8String url, url_without_protocol, url_for_ftp;
    
    if(ob_is_defined(Param1, L"URL")) {
        if(ob_get_s(Param1, L"URL", &url)) {
            if(url.length())
            {
                url_for_ftp = url;
                
                size_t pos = url.find((const uint8_t *)"://");
                if(pos != std::string::npos)
                {
                    /* skip protocol */
                    url_without_protocol = url.substr(pos + strlen("://"));
                }
                pos = url_without_protocol.find((const uint8_t *)"/");
                if(pos != std::string::npos)
                {
                    /* path: skip host */
                    path = std::string((const char *)url_without_protocol.substr(pos + 1).c_str());
                }
                if(removeFileName)
                {
                    /* remove last path component */
                    std::size_t pos = url.find_last_of((const uint8_t *)"/");
                    if((pos < url.length()) && (pos != std::string::npos))
                    {
                        url_for_ftp = url.substr(0, pos + 1);
                    }
                }
                
                if(0 == url_for_ftp.find((const uint8_t *)"sftp:"))
                {
                    protocol = PROTOCOL_TYPE_SFTP;
                }
                
                if(0 == url_for_ftp.find((const uint8_t *)"ftps:"))
                {
                    protocol = PROTOCOL_TYPE_FTPS;
                }
                
                if(0 == url_for_ftp.find((const uint8_t *)"ftp:"))
                {
                    protocol = PROTOCOL_TYPE_FTP;
                }
                
                switch (commandType) {
                    case curl_ftp_command_RemoveDir:
                    case curl_ftp_command_MakeDir:
                    {
                        if(url_for_ftp.size() > 0) {
                            if(url_for_ftp.at(url_for_ftp.size() - 1) != '/')
                                url_for_ftp += '/';
                        }
                    }
                        break;
                    default:
                        break;
                }
                
                curl_easy_setopt(curl, CURLOPT_URL, url_for_ftp.c_str());
            }
        }
    }

    return protocol;
}

static size_t apply_input_encoding(std::string& src, std::string& ie) {
    
    size_t iconv_value = 0;
    
    if(ie.length() != 0) {
        
        //convert
        const char *inEncoding = "utf-8";
        const char *outEncoding = ie.c_str();
        
        iconv_t conv = iconv_open(outEncoding, inEncoding);
        
        if (conv != (iconv_t)(-1)) {
            
            char *inData = (char *)src.c_str();
            size_t inDataLen = (size_t)src.length();
            size_t outDataLen = (size_t)(inDataLen * 4) + 4;
            size_t outDataSize = outDataLen;
            
            char *outData = (char *)calloc(outDataLen, 1);
            char *outDataPtr = outData;
            
            size_t iconv_value;
            
            iconv_value = iconv (conv, &inData, &inDataLen, &outData, &outDataLen);
            
            if (iconv_value)
            {
                /* errno */
            }else{
                src = std::string((const char *)outDataPtr, outDataSize-outDataLen);
            }
            free(outDataPtr);
            
            iconv_close(conv);
        }
    }
    
    return iconv_value;
}

static size_t apply_output_encoding(std::string& src, std::string& oe) {
    
    size_t iconv_value = 0;
    
    if(oe.length() != 0) {
        
        //convert
        const char *inEncoding = oe.c_str();
        const char *outEncoding = "utf-8";
        
        iconv_t conv = iconv_open(outEncoding, inEncoding);
        
        if (conv != (iconv_t)(-1)) {
            
            char *inData = (char *)src.c_str();
            size_t inDataLen = (size_t)src.length();
            size_t outDataLen = (size_t)(inDataLen * 4) + 4;
            size_t outDataSize = outDataLen;
            
            char *outData = (char *)calloc(outDataLen, 1);
            char *outDataPtr = outData;
            
            size_t iconv_value;
            
            iconv_value = iconv (conv, &inData, &inDataLen, &outData, &outDataLen);
            
            if (iconv_value)
            {
                /* errno */
            }else{
                src = std::string((const char *)outDataPtr, outDataSize-outDataLen);
            }
            free(outDataPtr);
            
            iconv_close(conv);
        }
    }
    
    return iconv_value;
}

static void curl_unescape_path(CURL *curl, std::string& path) {
    
    int ftp_path_len = 0;
    char *ftp_path = curl_easy_unescape(curl,
                                        path.c_str(),
                                        (int)path.length(),
                                        &ftp_path_len);
    path = std::string((const char *)ftp_path, ftp_path_len);
    curl_free(ftp_path);
}

static void remove_trailing_separator(CUTF8String& path) {
    
    if(path.length() > 1) {
        size_t pos = path.length() -1;
        
        if((path.compare(pos, 1, (const uint8_t *)"/") == 0))
        {
            path = path.substr(0, pos);
        }
    }
}

#if VERSIONWIN
static void remove_trailing_separator(CUTF16String& path) {
    
    if(path.length() > 1) {
        size_t pos = path.length() -1;
        
        if((path.compare(pos, 1, (const PA_Unichar *)L"\\") == 0))
        {
            path = path.substr(0, pos);
        }
    }
}
#endif

std::istream& safeGetline(std::istream& is, std::string& t)
{
	t.clear();

	// The characters in the stream are read one-by-one using a std::streambuf.
	// That is faster than reading them one-by-one using the std::istream.
	// Code that uses streambuf this way must be guarded by a sentry object.
	// The sentry object performs various tasks,
	// such as thread synchronization and updating the stream state.

	std::istream::sentry se(is, true);
	std::streambuf* sb = is.rdbuf();

	for (;;) {
		int c = sb->sbumpc();
		switch (c) {
		case '\n':
			return is;
		case '\r':
			if (sb->sgetc() == '\n')
				sb->sbumpc();
			return is;
		case std::streambuf::traits_type::eof():
			// Also handle the case when the last line has no line ending
			if (t.empty())
				is.setstate(std::ios::eofbit);
			return is;
		default:
			t += (char)c;
		}
	}
}
void cURL_FTP(PA_PluginParameters params, curl_ftp_command_t commandType) {
    
    PA_ObjectRef Param1 = PA_GetObjectParameter(params, 1); /* options */
    
    C_BLOB Param3; /* response */
    C_BLOB Param7;/* headerInfo */
    PA_ObjectRef returnValue  = PA_CreateObject();
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    C_BLOB Param2; /* request */
    C_TEXT Param4; /* callbackMethod */

    switch (commandType) {
        case curl_ftp_command_Send:
            Param2.fromParamAtIndex(pParams, 2);
            Param4.fromParamAtIndex(pParams, 3);
            break;
        case curl_ftp_command_Receive:
            Param4.fromParamAtIndex(pParams, 3);
            break;
        default:
            Param4.fromParamAtIndex(pParams, 2);
            break;
    }
        
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    
    CPathString request_path;
    CPathString response_path;
    
    std::string ie;
    std::string oe;
    
    std::string path;
    
    protocol_type_t protocol = curl_set_options_for_ftp(curl,
                                                        Param1,
                                                        request_path, response_path,
                                                        userInfo, ie, oe, path, commandType);
    std::string rename_to;
    
    switch (commandType) {
        case curl_ftp_command_Receive:
#if VERSIONMAC
    remove_trailing_separator(response_path);
#else
    remove_trailing_separator(response_path);
#endif
            break;
        case curl_ftp_command_Rename:
        {
            CUTF8String stringValue;
            if(ob_is_defined(Param1, L"RENAME_TO")) {
                if(ob_get_s(Param1, L"RENAME_TO", &stringValue)) {
                    rename_to = std::string((const char *)stringValue.c_str(), stringValue.length());
                    apply_input_encoding(rename_to, ie);
                }
            }
        }
            break;
        default:
            break;
    }
        
    http_ctx request_ctx;
    request_ctx.pos = 0L;
    request_ctx.data = &Param2; /* request */
    request_ctx.size = 0L;
    request_ctx.use_path = false;
    
    http_ctx response_ctx;
    response_ctx.pos = 0L;
    response_ctx.data = &Param3;/* response */
    response_ctx.size = 0L;
    response_ctx.use_path = false;
    
    http_ctx header_ctx;
    header_ctx.pos = 0L;
    header_ctx.data = &Param7;/* headerInfo */
    header_ctx.size = 0L;
    header_ctx.use_path = false;
    
    http_debug_ctx debug_ctx;
    
    debug_ctx.size_CURLINFO_TEXT = 0L;
    debug_ctx.size_CURLINFO_HEADER_IN = 0L;
    debug_ctx.size_CURLINFO_HEADER_OUT = 0L;
    debug_ctx.size_CURLINFO_DATA_IN = 0L;
    debug_ctx.size_CURLINFO_DATA_OUT = 0L;
    debug_ctx.size_CURLINFO_SSL_DATA_IN = 0L;
    debug_ctx.size_CURLINFO_SSL_DATA_OUT = 0L;
    
    CPathString debug_folder_path;
    
    if(curl_set_debug_option(curl,
                             Param1 /* options */,
                             debug_folder_path))
    {
#if VERSIONMAC
        debug_ctx.path = (const char *)debug_folder_path.c_str();
#else
        debug_ctx.path = (const wchar_t *)debug_folder_path.c_str();
#endif
        
        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);
        curl_easy_setopt(curl, CURLOPT_DEBUGDATA, &debug_ctx);
        curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, curl_debug_function);
    }
    
#if VERSIONMAC
    request_ctx.path = (const char *)request_path.c_str();
    response_ctx.path = (const char *)response_path.c_str();
#else
    request_ctx.path = (const wchar_t *)request_path.c_str();
    response_ctx.path = (const wchar_t *)response_path.c_str();
#endif

    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, (curl_off_t)Param2.getBytesLength());
    curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, (curl_off_t)Param2.getBytesLength());
    FILE *f = CPathOpen (request_ctx.path, CPathRead);
    if(f)
    {
        fseek(f, 0L, SEEK_END);
        request_ctx.size = (curl_off_t)ftell(f);
        fclose(f);
        
        if(request_ctx.size != -1L)
        {
            curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, request_ctx.size);
            curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, request_ctx.size);
        }
    }
    
    response_ctx.use_path = response_path.length();
    
    curl_easy_setopt(curl, CURLOPT_READDATA, &request_ctx);
    curl_easy_setopt(curl, CURLOPT_READFUNCTION, curl_read_function);

    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_ctx);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function);
    
    curl_easy_setopt(curl, CURLOPT_HEADERDATA, &header_ctx);
    curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, curl_header_function);
    
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    struct curl_slist *h = NULL;
    
    std::string quote;
        
    switch (commandType) {
        case curl_ftp_command_GetDirList:
            curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "LIST");
            curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
            curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
            break;
        case curl_ftp_command_GetFileInfo:
            curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
            curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
            curl_easy_setopt(curl, CURLOPT_FILETIME, 1L);
            break;
        case curl_ftp_command_MakeDir:
            apply_input_encoding(path, ie);
            curl_unescape_path(curl, path);
            curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
            curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
            switch (protocol) {
                case PROTOCOL_TYPE_SFTP:
                    quote = std::string((const char *)"mkdir \"/")
                    .append(path)
                    .append((const char *)"\"");
                    break;
                    
                default:
                    quote = std::string((const char *)"MKD ").append(path);
                    break;
            }
            h = curl_slist_append(h, (const char *)quote.c_str());
            curl_easy_setopt(curl, CURLOPT_QUOTE, h);
            break;
        case curl_ftp_command_PrintDir:
            curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
            curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
            curl_easy_setopt(curl, CURLOPT_DIRLISTONLY, 1L);
            break;
        case curl_ftp_command_Receive:
            curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
            curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
            break;
        case curl_ftp_command_RemoveDir:
            apply_input_encoding(path, ie);
            curl_unescape_path(curl, path);
            curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
            curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
            switch (protocol) {
                case PROTOCOL_TYPE_SFTP:
                    quote = std::string((const char *)"rmdir \"/")
                    .append(path)
                    .append((const char *)"\"");
                    break;
                    
                default:
                    quote = std::string((const char *)"RMD /")
                    .append(path);
                    break;
            }
            h = curl_slist_append(h, (const char *)quote.c_str());
            curl_easy_setopt(curl, CURLOPT_QUOTE, h);
            break;
        case curl_ftp_command_Rename:
            apply_input_encoding(path, ie);
            curl_unescape_path(curl, path);
            curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
            curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
            switch (protocol) {
                case PROTOCOL_TYPE_SFTP:
                    quote = std::string((const char *)"rename \"/")
                    .append(path)
                    .append((const char *)"\" ")
                    .append((const char *)"\"")
                    .append(rename_to)
                    .append((const char *)"\"");
                    break;
                    
                default:
                    quote = std::string((const char *)"RNFR /").append(path);
                    h = curl_slist_append(h, (const char *)quote.c_str());
                    quote = std::string((const char *)"RNTO ").append(rename_to);
                    break;
            }
            h = curl_slist_append(h, (const char *)quote.c_str());
            curl_easy_setopt(curl, CURLOPT_POSTQUOTE, h);
            break;
        case curl_ftp_command_Send:
            curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);
            curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
            curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
            break;
        case curl_ftp_command_System:
            curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
            curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
            curl_easy_setopt(curl, CURLOPT_FILETIME, 1L);
            h = curl_slist_append(h, "SYST");
            curl_easy_setopt(curl, CURLOPT_PREQUOTE, h);
            break;
  
        case curl_ftp_command_Delete:
            apply_input_encoding(path, ie);
            curl_unescape_path(curl, path);
            curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
            curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
            switch (protocol) {
                case PROTOCOL_TYPE_SFTP:
                    quote = std::string((const char *)"rm \"/")
                    .append(path)
                    .append((const char *)"\"");/* rm takes an absolute path */
                    break;
                    
                default:
                    quote = std::string((const char *)"DELE /")
                    .append(path);/* DELE takes a relative path;quote are not allowed */
                    break;
            }
            h = curl_slist_append(h, (const char *)quote.c_str());
            curl_easy_setopt(curl, CURLOPT_POSTQUOTE, h);
            break;
        default:
            break;
    }
        
    CURLcode status = CURLE_OK;
    
	CUTF16String methodName = (PA_Unichar *)Param4.getUTF16StringPtr();
    status = curl_perform_non_atomic(mcurl, curl, methodName, userInfo, returnValue);
    
    ob_set_n(returnValue, "status", status);
    
    /* convert headerInfo Param7:BLOB to Param6:TEXT */
    std::string headerInfo = std::string((const char *)Param7.getBytesPtr(), Param7.getBytesLength());
    ob_set_s(returnValue, "headerInfo", headerInfo.c_str());

    switch (commandType) {
        case curl_ftp_command_GetDirList:
        {
            std::string dirlist = std::string((const char *)Param3.getBytesPtr(), Param3.getBytesLength());
            apply_output_encoding(dirlist, oe);
            ob_set_s(returnValue, L"dirList", dirlist.c_str());
            
            std::istringstream is(dirlist);
            PA_CollectionRef directories = PA_CreateCollection();
            for (std::string line; safeGetline(is, line); )
            {
                struct ftpparse r;
                int found = ftpparse(&r, (char *)line.c_str(), (int)line.size());
                if (!found){
                    PA_Variable v = PA_CreateVariable(eVK_Null);                    
                    PA_SetCollectionElement(directories, PA_GetCollectionLength(directories), v);
                }
                else{
                    PA_ObjectRef f = PA_CreateObject();
                    
                    std::string name(r.name, r.namelen);
                    ob_set_s(f, L"name", name.c_str());
                    
                    std::string __id(r.id, r.idlen);
                    ob_set_s(f, L"id", __id.c_str());
                    
                    ob_set_n(f, L"flagtrycwd", r.flagtrycwd);
                    ob_set_n(f, L"flagtryretr", r.flagtryretr);
                    ob_set_n(f, L"size", r.size);
                    
                    switch (r.sizetype) {
                        case FTPPARSE_SIZE_UNKNOWN:
                            ob_set_s(f, L"sizetype", "UNKNOWN");
                            break;
                        case FTPPARSE_SIZE_BINARY:
                            ob_set_s(f, L"sizetype", "BINARY");
                            break;
                        case FTPPARSE_SIZE_ASCII:
                            ob_set_s(f, L"sizetype", "ASCII");
                            break;
                    }
                    
                    ob_set_n(f, L"sizetype", r.sizetype);
                    
                    switch (r.idtype) {
                        case FTPPARSE_ID_UNKNOWN:
                            ob_set_s(f, L"idtype", "UNKNOWN");
                            break;
                        case FTPPARSE_ID_FULL:
                            ob_set_s(f, L"idtype", "BINARY");
                            break;
                    }
                                        
                    time_t mtime = r.mtime;
                    
                    switch (r.mtimetype) {
                        case FTPPARSE_MTIME_UNKNOWN:
                            ob_set_s(f, L"mtimetype", "UNKNOWN");
                            break;
                        case FTPPARSE_MTIME_LOCAL:
                            ob_set_s(f, L"mtimetype", "LOCAL");
                            break;
                        case FTPPARSE_MTIME_REMOTEMINUTE:
                            ob_set_s(f, L"mtimetype", "REMOTEMINUTE");
                            break;
                        case FTPPARSE_MTIME_REMOTEDAY:
                            ob_set_s(f, L"mtimetype", "REMOTEDAY");
                            break;
                        default:
                            break;
                    }
                    
					std::vector<uint8_t> buf(32);
					memset((char *)&buf[0], 0, buf.size());

                    if(r.mtimetype == FTPPARSE_MTIME_LOCAL) {
                        strftime((char *)&buf[0], buf.size(), "%Y-%m-%dT%H%:M%:S%z",  localtime(&mtime));
                    }else{
                        strftime((char *)&buf[0], buf.size(), "%Y-%m-%dT%H:%M:%S%z",  gmtime(&mtime));
                    }

                    ob_set_s(f, L"mtime", (char *)&buf[0]);
                    
                    PA_Variable v = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&v, f);
                    
                    PA_SetCollectionElement(directories, PA_GetCollectionLength(directories), v);
                }
            }
            ob_set_c(returnValue, L"ftpparse", directories);
        }
            break;
        case curl_ftp_command_GetFileInfo:
        {
            curl_off_t fileSize = 0;
            PA_ObjectRef fileInfo = PA_CreateObject();
            if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD_T, &fileSize))
            {
                ob_set_n(fileInfo, L"size", fileSize);
            }
            long _fileTime;
            if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FILETIME, &_fileTime))
            {
                char buf[80];
                time_t fileTime = (time_t)_fileTime;
                struct tm ts = *gmtime(&fileTime);
                strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%SZ", &ts);
                char *fileDate = (char *)buf;
                ob_set_s(fileInfo, L"date", fileDate ? fileDate : "");
            }
            ob_set_o(returnValue, L"fileInfo", fileInfo);
        }
            break;
        case curl_ftp_command_MakeDir:
            curl_slist_free_all(h);
            break;
        case curl_ftp_command_PrintDir:
        {
            std::string dirlist = std::string((const char *)Param3.getBytesPtr(), Param3.getBytesLength());
            apply_output_encoding(dirlist, oe);
            ob_set_s(returnValue, L"dirList", dirlist.c_str());
        }
            break;
        case curl_ftp_command_Receive:
            Param3.toParamAtIndex(pParams, 2);
            break;
        case curl_ftp_command_Delete:
            curl_slist_free_all(h);
            break;
        case curl_ftp_command_RemoveDir:
            curl_slist_free_all(h);
            break;
        case curl_ftp_command_Rename:
            curl_slist_free_all(h);
            break;
        case curl_ftp_command_Send:
            //nothing to do
            break;
        case curl_ftp_command_System:
        {
            curl_slist_free_all(h);
            std::string _system = std::string((const char *)Param3.getBytesPtr(), Param3.getBytesLength());
            apply_output_encoding(_system, oe);
            ob_set_s(returnValue, L"system", _system.c_str());
        }
            break;
        default:
            break;
    }
    
    /* cleanup */
    
    curl_easy_cleanup(curl);

    PA_ReturnObject(params, returnValue);
}
